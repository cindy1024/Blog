{"meta":{"title":"安静土","subtitle":"Glad You Came","description":"一只蘑菇","author":"蘑蘑蘑的菇","url":"https://abc.hey-world.xyz"},"pages":[{"title":"categories","date":"2018-07-27T09:41:59.000Z","updated":"2018-07-28T09:11:00.066Z","comments":false,"path":"categories/index.html","permalink":"https://abc.hey-world.xyz/categories/index.html","excerpt":"","text":""},{"title":"About me","date":"2018-07-27T09:44:21.000Z","updated":"2019-04-23T08:51:41.612Z","comments":true,"path":"about/index.html","permalink":"https://abc.hey-world.xyz/about/index.html","excerpt":"","text":"CS在读，爱好羽毛球 日志 2019-03-23：更换域名，更新不蒜子统计，更换图床，添加文章底部版权样式。 2018-07-27：启用Next主题，自定义样式克隆自CHANGE・業・德，表示感谢 2017-07-24：启用主题Material 2017-02-01：建博"},{"title":"写啊！少年","date":"2020-02-10T04:10:11.048Z","updated":"2019-04-27T08:14:48.231Z","comments":true,"path":"mind/index.html","permalink":"https://abc.hey-world.xyz/mind/index.html","excerpt":"","text":"句"},{"title":"Master-Mind Hints","date":"2017-08-15T13:25:44.000Z","updated":"2019-04-27T08:14:53.493Z","comments":true,"path":"questions/Master-Mind-Hints.html","permalink":"https://abc.hey-world.xyz/questions/Master-Mind-Hints.html","excerpt":"猜数字游戏的提示。","text":"猜数字游戏的提示。 题目 340猜数字游戏，给定用户序列a secret code和答案序列guesses，统计有多少数字位置正确（A）a strong match，多少数字在两个序列都出现过但位置不对（B）a weak match。 输入第一行为序列长度n，第二行为答案序列，接下来是猜测序列。猜测序列为全零，该组数据结束；n=0时输入结束。（数字1~9） s[i]==p[j] 且 i==j 时, a strong matchs[i]==p[j] 且 i!=j 时, a weak match Sample Input Sample Output注意输入格式，序列前面有4个空格 orz… 分析起初思维被限定，按照count流程一个个计算，要考虑很多情况，非常麻烦。 参考刘汝佳思路：直接统计可得A。为了求B，对每个数字，统计在二者出现的次数c1和c2，min(c1, c2)是该数字对B的贡献。最后的最后减去A的部分。 用数组a、b分别统计每个数字在两序列出现次数。 解决#include &lt;string.h> #include &lt;iostream> using namespace std; int main() { int n; int game = 0; int a[10] = { 0 }; while (cin >> n) { if (n == 0) break; int *num = new int[n]; for (int i = 0; i &lt; n; i++) { int x; cin >> x; num[i] = x; a[x]++; } cout &lt;&lt; \"Game \" &lt;&lt; ++game &lt;&lt; \":\" &lt;&lt; endl; while (1) { int b[10] = { 0 }; int zero,correct, dislocate; //输入0的个数、A个数、B个数 zero = correct = dislocate = 0; for (int i = 0; i &lt; n; i++) { int x; cin >> x; b[x]++; if (x == 0) zero++; if (x == num[i]) correct++; } if (zero == n) break; for (int i = 1; i &lt; 10; i++) { dislocate += a[i] &lt;= b[i] ? a[i] : b[i]; } dislocate -= correct; cout &lt;&lt; '(' &lt;&lt; correct &lt;&lt; ',' &lt;&lt; dislocate &lt;&lt; ')' &lt;&lt; endl; } memset(a, 0, sizeof(a)); delete[] num; } return 0; }"},{"title":"Palindrome Number","date":"2017-08-08T09:11:18.000Z","updated":"2017-08-12T15:08:37.154Z","comments":true,"path":"questions/Palindrome-Number.html","permalink":"https://abc.hey-world.xyz/questions/Palindrome-Number.html","excerpt":"判断回文数。","text":"判断回文数。 题目 9Determine whether an integer is a palindrome. Do this without extra space. click to show spoilers. Some hints:Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case? There is a more generic way of solving this problem. 分析负号不对称，负数不是回文数。 解决用了额外的栈和队列空间。 bool isPalindrome(int x) { if (x &lt; 0) return false; stack&lt;int> s; queue&lt;int> q; while (x != 0) { int tmp = x % 10; s.push(tmp); q.push(tmp); x /= 10; } while (s.size()) { if (s.top() == q.front()) { s.pop(); q.pop(); } else return false; } return true; } 参考Only reversing till half and then compare. 007-Reverse-Integer 空间复杂度O(1)，与问题规模n无关。 bool isPalindrome(int x) { if(x&lt;0|| (x!=0 &amp;&amp;x%10==0)) return false; //10的倍数必定不是回文数 int sum=0; while(x>sum) { sum = sum*10+x%10; x = x/10; } return (x==sum)||(x==sum/10); //偶数位、奇数位 }"},{"title":"Reverse Integer","date":"2017-08-03T04:31:08.000Z","updated":"2017-11-21T13:33:12.271Z","comments":true,"path":"questions/Reverse-Integer.html","permalink":"https://abc.hey-world.xyz/questions/Reverse-Integer.html","excerpt":"翻转32位有符号整型数字，注意溢出。","text":"翻转32位有符号整型数字，注意溢出。 题目 7Reverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321 Note: The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows. 分析 32位有符号整型范围：$[-2^{31} , 2^{31}-1]$ 溢出 int y = a*b; 在得出a*b的结果时已经溢出（在赋值之前） 解决int reverse(int x) { const int max = pow(2, 31) - 1; if (x > max || x &lt; -max - 1) return 0; double y = 0; while( x != 0) { double tmp = y * 10 + (x % 10); y = (tmp > max || tmp &lt; -max - 1) ? 0:tmp; //判断溢出 x /= 10; } return (int)y; } 参考主体过程一样，区别在于对溢出的处理： 用long保存中间转换数 long赋值给int，若赋值后两边不等，溢出。 class Solution { public: int reverse(int x) { long long numReversed = 0; //长整型64位 int num = x; while ( num != 0 ) { numReversed = numReversed * 10 + num % 10; num /= 10; } int y = numReversed; if (y == numReversed) return y; else return 0; } }; something数的表示 科学计数法 2E31 =&gt; $2* (10^{31})$ 次方的表示 pow(2,31) =&gt; $2^{31}$ （注：头文件&lt;math.h&gt;） 如何判断溢出"},{"title":"String to Integer","date":"2017-08-03T11:02:17.000Z","updated":"2017-08-12T15:08:19.344Z","comments":true,"path":"questions/String-to-Integer.html","permalink":"https://abc.hey-world.xyz/questions/String-to-Integer.html","excerpt":"实现atoi函数。","text":"实现atoi函数。 题目 8Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. 分析 atoi (ascii to integer)把字符串转换成整型数。跳过前面的空白字符（例如空格，tab缩进等。可以通过isspace( )函数来检测），直到遇上数字或正负符号才开始做转换，而在遇到非数字或字符串结束时(‘\\0’)才结束转换，并将结果返回。如果 nptr不能转换成 int 或者 nptr为空字符串，那么将返回 0。 题目说明包含所有输入情况，需要考虑： 开头过滤空白字符 isspace( )函数 符号位 顺序 ${(blank character)}^{*} {(+|-)}^{*} {(num)}^{*}$ 溢出 无效输入 连着2个符号位及以上 “+ 123” 奇葩输入： “ 001” “18446744073709551617” 解决可改进： 过滤符号位麻烦，类似’+-‘情况直接放最后考虑。 判断溢出 最终处理符号位 * int myAtoi(string str) { int num = 0; int flag = 0; //记录符号位 int i,start; bool overflow = false; //溢出标志 for (i = 0; isspace(str[i]); i++) {} //过滤空白符 start = i; // for (; i &lt; str.length(); i++) { //过滤'+'、'-' if (str[i] == '+') flag++; else if (str[i] == '-') flag--; else break; } for (; i &lt; str.length(); i++) { if (str[i] >= '0' &amp;&amp; str[i] &lt;= '9') { //num = num * 10 + str[i] - 48; int tmp = num * 10; if (tmp / 10 != num) //乘法溢出 overflow = true; num = tmp + str[i] - 48; if (overflow == false &amp;&amp; num &lt; 0) overflow = true; //加法溢出 if (i == start) flag = 1; //没有'+'、'-'符号出现 } else break; } switch (flag) { case 1: if (overflow) return INT_MAX; else return num; case -1: if (overflow) return INT_MIN; else return -1 * num; default: return 0; } } 参考 用i++连接三个过程 对溢出的判断 INT_MIN -2147483648 被误判为overflow，但结果恰好正确。 int atoi(const char *str) { int sign = 1, base = 0, i = 0; while (str[i] == ' ') { i++; } if (str[i] == '-' || str[i] == '+') { sign = 1 - 2 * (str[i++] == '-'); //先赋值再++ } while (str[i] >= '0' &amp;&amp; str[i] &lt;= '9') { //判断溢出 if (base > INT_MAX / 10 || (base == INT_MAX / 10 &amp;&amp; str[i] - '0' > INT_MAX % 10)) { if (sign == 1) return INT_MAX; else return INT_MIN; } base = 10 * base + (str[i++] - '0'); } return base * sign; } something INT_MAX等范围值在&lt;limits.h&gt;文件中。 判断溢出"},{"title":"ZigZag Conversion","date":"2017-08-03T03:05:31.000Z","updated":"2017-08-12T15:08:26.980Z","comments":true,"path":"questions/ZigZag-Conversion.html","permalink":"https://abc.hey-world.xyz/questions/ZigZag-Conversion.html","excerpt":"把字符串转换成之字形，重新读取字串。","text":"把字符串转换成之字形，重新读取字串。 题目 6The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H N A P L S I I G Y I R And then read line by line: &quot;PAHNAPLSIIGYIR&quot;Write the code that will take a string and make this conversion given a number of rows: string convert(string text, int nRows); convert(&quot;PAYPALISHIRING&quot;, 3) should return &quot;PAHNAPLSIIGYIR&quot;. 分析找规律题 解决每行的首字母之后都依次分析第一个字母(nRows-1-i)*2、第二个字母(nRows-1)*2，繁琐。 string convert(string text, int nRows) { int l_space, r_space, l_letter, r_letter; int t; string res; if(nRows == 1) return text; for (int i = 0; i &lt; nRows; i++) { l_letter = (nRows - 1 - i) * 2; r_letter = 2 * i; t = i; res.push_back(text[t]); while (t + l_letter &lt; text.length()) { if (l_letter != 0) res.push_back(text[t + l_letter]); if (t + (nRows - 1) * 2 >= text.length()) break; //若第二个字母超出范围，本行已经到末尾 if (r_letter != 0) res.push_back(text[t + l_letter + r_letter]); t = t + (nRows - 1) * 2; //更新某行的当前标记 if (t == 0) break; //只有一个字符 } } return res; } 参考间隔列固定 2*numRows-2，（除了首行和末尾行）中间字母规律2*(numRows-1-i)。 class Solution { public: string convert(string s, int numRows) { if(numRows==1) return s; string rel=\"\"; int l=s.length(); int add=2*numRows-2; for(int i=0;i&lt;numRows;i++){ for(int j=i;j&lt;l;j+=add){ //把步长增加放到for循环中 rel+=s[j]; //固定列字母 int flag=j+2*(numRows-1-i); if(i!=0&amp;&amp;i!=numRows-1&amp;&amp;flag&lt;l){ //非首尾行，且 flag&lt;l rel+=s[flag]; //中间字母 } } } return rel; } };"},{"title":"翻完我的简讯我的信 顺便翻翻我的心情","date":"2017-11-06T10:01:31.000Z","updated":"2018-01-16T14:42:14.481Z","comments":true,"path":"mind/翻完我的简讯我的信-顺便翻翻我的心情.html","permalink":"https://abc.hey-world.xyz/mind/翻完我的简讯我的信-顺便翻翻我的心情.html","excerpt":"","text":"2017.11.09 天气 晴 从网易云转战虾米，开始拾起很久没听的林宥嘉。熟悉的感觉，神游live的每一首歌似乎都那么熟悉。在学校广播听见yoga，开心得可以蹦起来，享受。"},{"title":"Container With Most Water","date":"2017-11-09T07:13:18.000Z","updated":"2017-11-09T07:25:30.329Z","comments":true,"path":"questions/container-with-most-water.html","permalink":"https://abc.hey-world.xyz/questions/container-with-most-water.html","excerpt":"装最多水的容器。","text":"装最多水的容器。 题目 11Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. 给定 n 个非负整数 a1, a2, …, an, 每个数代表了坐标中的一个点 (i, ai)。画 n 条垂直线，使得 i 垂直线的两个端点分别为(i, ai)和(i, 0)。找到两条线，使得其与 x 轴共同构成一个容器，以容纳最多水。 分析一开始看到题目有些发懵，反复读了几遍，其实就是 木桶效应+最大长方形 问题的结合。两条直线中，较短的一条成为短板。用两个指针分别从左右开始往中间走，希望继续寻找比短板更高的直线。过程比较简单。 解决 int maxArea(vector&lt;int>&amp; height) { int maxArea = 0; int area = 0; int i = 0; int j = height.size() - 1; while (i &lt; j) { if (height[i] &lt;= height[j]) { area = (j - i)*height[i]; //计算面积 i++; //左边指针往中间走 } else { area = (j - i)* height[j]; //计算面积 j--; //右边指针往中间走 } if (area > maxArea) maxArea = area; } return maxArea; }"},{"title":"tags","date":"2018-07-27T09:42:54.000Z","updated":"2018-07-28T09:11:36.161Z","comments":false,"path":"tags/index.html","permalink":"https://abc.hey-world.xyz/tags/index.html","excerpt":"","text":""},{"title":"奋起啊！少年","date":"2020-02-11T04:00:22.083Z","updated":"2020-02-11T04:00:22.083Z","comments":true,"path":"questions/index.html","permalink":"https://abc.hey-world.xyz/questions/index.html","excerpt":"","text":"题库leetcode 006 ZigZag Conversion 把字符串转换成之字形，重新读取字串。 007 Reverse Integer 翻转32位有符号整型数字，注意溢出。 008 String to Integer 实现atoi函数。 009 Palindrome Number 判断回文数。 011 Container With Most Water 木桶效应+最大长方形。 012/013 Integer to Roman / Roman to Integer 整型、罗马数字互转。 014 Longest Common Prefix 最长共同前缀。 UVa 0401 Palindromes 判断回文串或镜像串。 0340 Master-Mind Hints 猜数字游戏的提示。 1583 Digit Generator 生成元。 剑指Offer 002 实现Singleton模式 一个类只产生一个实例。 分类string leetcode - 006 ZigZag Conversion leetcode - 008 String to Integer UVa- 0401 Palindromes leetcode - 012/013 Integer to Roman / Roman to Integer leetcode - 014 Longest Common Prefix 最长共同前缀。 math leetcode - 007 Reverse Integer leetcode - 008 String to Integer leetcode - 009 Palindrome Number UVa - 0340 Master-Mind Hints UVa - 1583 Digit Generator leetcode - 012 Integer to Roman array leetcode - 011 Container With Most Water 设计模式 002 实现Singleton模式"},{"title":"Integer to Roman / Roman to Integer","date":"2017-11-09T08:44:09.000Z","updated":"2017-11-21T13:39:17.308Z","comments":true,"path":"questions/integer-to-roman.html","permalink":"https://abc.hey-world.xyz/questions/integer-to-roman.html","excerpt":"整型、罗马数字互转。","text":"整型、罗马数字互转。 题目 12Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. 题目 13Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 分析摸清罗马数字的规律。罗马数字wiki index 0 1 2 3 4 5 6 Roman I V X L C D M value 1 5 10 50 100 500 1000 t = 1, 3, 5 个位与IVX有关，十位与XLC有关，百位与CDM有关。 余数 该位对应的罗马数字 0 1 - 3 (t-1)…(t-1) 4 (t-1)(t) 5 - 8 (t)(t+1)…(t+1) 9 (t-1)(t+1) 解决Int To Roman：根据数字符号的对应规律，从高位数字开始转换 string intToRoman(int num) { char roman[7] = {'I','V','X','L','C','D','M'}; int t = 1; string res = \"\"; do { string str = \"\"; int x = num % 10; if (!x) { t += 2; num /= 10; continue; } if (x &lt; 4) for (int i = 0; i &lt; x; i++) str += roman[t - 1]; if (x == 4) { str += roman[t - 1]; str += roman[t]; } if (x > 4 &amp;&amp; x &lt; 9) { str += roman[t]; for (int i = 0; i &lt; x - 5; i++) str += roman[t - 1]; } if (x == 9) { str += roman[t - 1]; str += roman[t + 1]; } t += 2; num /= 10; res.insert(0, str); //把每一位求得的编码从头插入，不然会倒序 } while (num); return res; } Roman To Int：一个个字符地转成数字意义 int romanToInt(string s) { int res = 0; unordered_map&lt;char, int> map; map['I'] = 1; map['V'] = 5; map['X'] = 10; map['L'] = 50; map['C'] = 100; map['D'] = 500; map['M'] = 1000; bool start = true;// int i = 1; for (; i &lt; s.size(); i++) { res += toInt(map[s[i - 1]], map[s[i]], start); } if(start) res += map[s[i - 1]]; return res; } int toInt(int a, int b, bool &amp;start) { int t = 0; if (a >= b &amp;&amp; a / b &lt; 10) { t += b; if (start) { t += a; } start = false; } else if (b > a) { t += b - a; start = false; } else if (start) t += a; else start = true; return t; }"},{"title":"timeline","date":"2020-02-10T04:10:26.879Z","updated":"2017-08-11T02:13:48.472Z","comments":true,"path":"timeline/index.html","permalink":"https://abc.hey-world.xyz/timeline/index.html","excerpt":"","text":""},{"title":"Palindrome Number","date":"2017-08-12T09:44:44.000Z","updated":"2017-08-15T16:21:55.142Z","comments":true,"path":"questions/Palindromes.html","permalink":"https://abc.hey-world.xyz/questions/Palindromes.html","excerpt":"判断字符串是否为回文串或镜像串。","text":"判断字符串是否为回文串或镜像串。 题目 401InputInput consists of strings (one per line) each of which will consist of one to twenty valid characters.There will be no invalid characters in any of the strings. Your program should read to the end of file. OutputFor each input string, you should print the string starting in column 1 immediately followed by exactly one of the following strings. Sample InputNOTAPALINDROMEISAPALINILAPASI2A3MEASATOYOTA Sample OutputNOTAPALINDROME – is not a palindrome.ISAPALINILAPASI – is a regular palindrome.2A3MEAS – is a mirrored string.ATOYOTA – is a mirrored palindrome. Note ‘0’ (zero) and ‘O’ (the letter) are considered the same character and therefore ONLY the letter ‘O’ is a valid character. The output line is to include the ‘-’s and spacing exactly as shown in the table above and demonstrated in the Sample Output below. In addition, after each output line, you must print an empty line. 分析依次首尾比较。 解决用string数组存储输出信息，用p * 2 + m计算标志位来输出信息。 #include &lt;string> #include &lt;iostream> using namespace std; const string reverse = \"A 3 HIL JM O 2TUVWXY51SE Z 8 \"; const string message[4] = { \"not a palindrome\",\"a mirrored string\",\"a regular palindrome\",\"a mirrored palindrome\" }; char mirror(char ch) { if (ch >= 'A' &amp;&amp; ch &lt;= 'Z') return reverse[ch - 'A']; if (ch >= '0' &amp;&amp; ch &lt;= '9') return reverse[ch - '0' + 25]; } int main() { string s; while(cin >> s) { bool p, m; p = m = true; int len = s.size(); for (int i = 0; i &lt; len; i++) { if (s[i] != s[len - i - 1]) p = false; if (s[i] != mirror(s[len - i - 1])) m = false; } cout &lt;&lt; s &lt;&lt; \" -- is \" &lt;&lt; message[p * 2 + m] &lt;&lt; \".\" &lt;&lt;endl &lt;&lt;endl; } return 0; }"},{"title":"Digit Generator","date":"2017-08-17T07:53:17.000Z","updated":"2017-08-17T07:53:34.291Z","comments":true,"path":"questions/Digit-Generator.html","permalink":"https://abc.hey-world.xyz/questions/Digit-Generator.html","excerpt":"生成元。","text":"生成元。 题目 1583如果x加上x的各个数字之和等于y，就说x是y的生成元。245是256 (= 245 + 2 + 4 + 5)的生成元。 有的数字没有生成元，有的数字不止一个（找到最小的）。 InputYour program is to read from standard input. The input consists of T test cases. The number of test cases T is given in the first line of the input. Each test case takes one line containing an integer N, 1 ≤ N ≤ 100, 000. OutputYour program is to write to standard output. Print exactly one line for each test case. The line is to contain a generator of N for each test case. If N has multiple generators, print the smallest. If N does not have any generators, print ‘0’. Sample Input3 216 121 2005 Sample Output198 0 1979 分析遍历N-1个数效率低，利用 y - x数字之和 = x ，对于y，判断 (y - sum)的数字之和与sum是否相等。首先要求y的位数n，sum的最大可能为 n * 9（x由n个9组成）。 解决#include &lt;iostream> using namespace std; int getDigit(int x) { int nDigit = 1; while (x) { x /= 10; nDigit++; } return nDigit; } int getSumDigit(int x) { int sum = 0; while (x) { int tmp = x % 10; sum += tmp; x /= 10; } return sum; } int main() { int c; while (cin >> c) { int x; for (int k = 0;cin >> x &amp;&amp; k &lt; c; k++) { int n = getDigit(x); int res = 0; for (int i = 9 * n; i >= 0; i--) { if (i == getSumDigit(x - i) ) { res = x - i; break; } } cout &lt;&lt; res &lt;&lt; endl; } } return 0; } 参考刘汝佳的做法：枚举100000内所有正整数x，计算y，生成表。要用时查表 其他快速取得一个整数的最高位查资料过程看到，只有一点相关，但要记录每一位的情况下还是老办法好。 最佳：Unrolled &amp; optimized loop if (i >= 100000000) i /= 100000000; if (i >= 10000) i /= 10000; if (i >= 100) i /= 100; if (i >= 10) i /= 10;"},{"title":"Longest Common Prefix","date":"2017-11-21T13:16:44.000Z","updated":"2017-11-21T13:39:15.001Z","comments":true,"path":"questions/longest-common-prefix.html","permalink":"https://abc.hey-world.xyz/questions/longest-common-prefix.html","excerpt":"最长共同前缀。","text":"最长共同前缀。 题目 14Write a function to find the longest common prefix string amongst an array of strings. 分析 横向看 （先数组，再看列）$LCP(S{1}…S{n})=LCP(LCP(LCP(S{1},S{2}),S{3}),…S{n})$ 纵向看（先看列，再数组） 解决纵向 string longestCommonPrefix(vector&lt;string>&amp; strs) { string str = \"\"; if (strs.size() == 0) return str; for (int i = 0; i &lt; strs[0].size(); i++) { //每一列 char ch = strs[0][i]; bool flag = true; for (int j = 1; j &lt; strs.size(); j++) { //数组（相当于行） if (ch != strs[j][i]) { flag = false; //用标记记录进程，改进见参考 break; } } if (flag) str += ch; else break; } return str; } 参考横向 public String longestCommonPrefix(String[] strs) { if (strs.length == 0) return \"\"; String prefix = strs[0]; for (int i = 1; i &lt; strs.length; i++) while (strs[i].indexOf(prefix) != 0) { prefix = prefix.substring(0, prefix.length() - 1); if (prefix.isEmpty()) return \"\"; } return prefix; } 纵向 public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) return \"\"; for (int i = 0; i &lt; strs[0].length() ; i++){ char c = strs[0].charAt(i); for (int j = 1; j &lt; strs.length; j ++) { if (i == strs[j].length() || strs[j].charAt(i) != c) return strs[0].substring(0, i); //flag改进成 } } return strs[0]; } 另一种想法：从长到短。先假设prefix为第一个串，依次比较其他串，改变prefix的位数。 string longestCommonPrefix(vector&lt;string>&amp; strs) { if (strs.size() == 0) { return \"\"; } string prefix = strs[0]; for (int i = 1; i &lt; strs.size(); i++) { while (0 != strs[i].compare(0, prefix.length(), prefix)) { prefix = prefix.substr(0, prefix.length()-1); } } return prefix; }"},{"title":"实现Singleton模式","date":"2020-10-09T04:17:00.000Z","updated":"2020-02-11T03:59:35.920Z","comments":true,"path":"questions/offer/002_实现Singleton模式.html","permalink":"https://abc.hey-world.xyz/questions/offer/002_实现Singleton模式.html","excerpt":"c#实现单例模式。","text":"c#实现单例模式。 题目 002设计一个类，只能生成该类的一个实例。 分析要求只能生成一个实例，构造函数设为私有，其他类不能直接调用该类生成新的对象。“只能生成一个”，想到static的特性。 几种解法 方法一：判断静态成员变量是否为空，只适用于单线程。 方法二：在方法一的基础上，加同步锁再判断，可用于多线程。 方法三：修改方法二，加同步锁前后两次判断，减少加锁操作，提高效率。 方法四：静态构造函数，可能会过早地创建实例。 创建第一个类实例或任何静态成员被引用时，.NET将自动调用静态构造函数来初始化类。 public sealed class Singleton4 { private Singleton4(){} private static Singleton4 instance = new Singleton4(); public static Singleton4 Instance { get { return instance; } } } 方法五：按需创建，嵌套类+静态函数。 父类的方法用static修饰，是为了绕过类的实例化来调用函数。【必须】 子类的方法和变量用static修饰，是因为静态方法不能直接调用非静态成员。 public sealed class Singleton5 { Singleton5(){} public static Singleton5 Instance { get { return Nested.instance; } } class Nested { static Nested(){} internal static readonly Singleton5 instance = new Singleton5(); } } 对方法五做如下修改，使得在Nested类中，不使用静态函数和变量（即方法五中子类不适用static），可达到相同效果： public sealed class Singleton5 { Singleton5(){} public static Singleton5 Instance { get { Nested n = new Nested(); //modified return n.instance; //modified } } public class Nested { internal Nested(){} //modified internal readonly Singleton5 instance = new Singleton5(); //modified } } 扩展什么时候可以不用实例化对象就可以调用类中成员函数？ 类的静态成员函数。 非静态成员函数没有使用类的非静态数据成员，调用的其他非静态成员函数也不能使用类的非静态数据成员。 非静态成员函数调用类的静态数据成员。 （后面两种可以概括为【non-static的东西没有调用non-static的东西】） 来源：https://blog.csdn.net/dwb1015/article/details/32933349"}],"posts":[{"title":"解决xftp5：要继续使用此程序，您必须应用最新的更新或使用新版本","slug":"不升级解决xftp5：要继续使用此程序，您必须应用最新的更新或使用新版本","date":"2019-04-24T13:19:08.000Z","updated":"2019-04-24T13:46:46.648Z","comments":true,"path":"2019/04/24/不升级解决xftp5：要继续使用此程序，您必须应用最新的更新或使用新版本/","link":"","permalink":"https://abc.hey-world.xyz/2019/04/24/不升级解决xftp5：要继续使用此程序，您必须应用最新的更新或使用新版本/","excerpt":"","text":"不升级，解决xftp5：要继续使用此程序，您必须应用最新的更新或使用新版本。 文本方式打开nslicense.dll 搜索16进制 7F0C81F98033E1010F8680修改为 7F0C81F98033E101E98100 或 7F0C81F98033E1010F8380 参考：Xshell无法启动：要继续使用此程序，您必须应用最新的更新或使用新版本","categories":[{"name":"warning&error","slug":"warning-error","permalink":"https://abc.hey-world.xyz/categories/warning-error/"}],"tags":[{"name":"搜索是王道","slug":"搜索是王道","permalink":"https://abc.hey-world.xyz/tags/搜索是王道/"}]},{"title":"Windows下通过sublime text批量替换多个文件","slug":"Windows下通过sublime-text批量替换多个文件","date":"2019-04-24T12:28:54.000Z","updated":"2019-04-24T13:44:58.104Z","comments":true,"path":"2019/04/24/Windows下通过sublime-text批量替换多个文件/","link":"","permalink":"https://abc.hey-world.xyz/2019/04/24/Windows下通过sublime-text批量替换多个文件/","excerpt":"","text":"Linux系统下可以用sed命令一键替换，Windows下的懒人模式，发现sublime text的新用途。 sublime text选择“文件”-“打开文件夹” 把含有要替换文本的文件放在一个文件夹内（可以包含多层级多个子文件夹），选择该文件夹。 在文件夹处右键“在文件夹中查找”，即可在多个文件中查找或替换文本。 左下角表示支持正则、大小写、全词匹配","categories":[{"name":"工具","slug":"工具","permalink":"https://abc.hey-world.xyz/categories/工具/"}],"tags":[{"name":"搜索是王道","slug":"搜索是王道","permalink":"https://abc.hey-world.xyz/tags/搜索是王道/"}]},{"title":"用python为png图片加上背景色","slug":"用python为png图片加上背景色","date":"2018-07-28T08:43:19.000Z","updated":"2018-07-28T08:48:04.181Z","comments":true,"path":"2018/07/28/用python为png图片加上背景色/","link":"","permalink":"https://abc.hey-world.xyz/2018/07/28/用python为png图片加上背景色/","excerpt":"","text":"安装Pillow库ImportError: No module named PIL 错误 的解决方法： pip install Pillow 代码from PIL import Image as Image im = Image.open('cropped-1920-1080-744835.png') x,y = im.size try: p = Image.new('RGB', im.size, (178, 235, 242)) #创建背景色图像 p.paste(im, (0, 0, x, y), im) #将原图粘贴到背景图像上 p.save('out-cropped-1920-1080-744835.png') except: pass PIL.Image.new(mode, size, color=0)Creates a new image with the given mode and size. mode 1 (1-bit pixels, black and white, stored with one pixel per byte) L (8-bit pixels, black and white) P (8-bit pixels, mapped to any other mode using a color palette) RGB (3x8-bit pixels, true color) RGBA (4x8-bit pixels, true color with transparency mask) CMYK (4x8-bit pixels, color separation) YCbCr (3x8-bit pixels, color video format) Note that this refers to the JPEG, and not the ITU-R BT.2020, standard LAB (3x8-bit pixels, the Lab color space) HSV (3x8-bit pixels, Hue, Saturation, Value color space) I (32-bit signed integer pixels) F (32-bit floating point pixels) Image.paste(im, box=None, mask=None)**Parameters: im – Source image or pixel value (integer or tuple). box – An optional 4-tuple giving the region to paste into. If a 2-tuple is used instead, it’s treated as the upper left corner. If omitted or None, the source is pasted into the upper left corner. If an image is given as the second argument and there is no third, the box defaults to (0, 0), and the second argument is interpreted as a mask image. 四元组：左上右下 mask – An optional mask image. 引用python通过pil为png图片填充上背景颜色 Image Module | Pillow","categories":[{"name":"工具","slug":"工具","permalink":"https://abc.hey-world.xyz/categories/工具/"}],"tags":[{"name":"python","slug":"python","permalink":"https://abc.hey-world.xyz/tags/python/"},{"name":"png","slug":"png","permalink":"https://abc.hey-world.xyz/tags/png/"}]},{"title":"C++如何判断整型运算溢出","slug":"C-如何判断整型运算溢出","date":"2017-08-04T08:27:08.000Z","updated":"2018-07-27T11:41:55.176Z","comments":true,"path":"2017/08/04/C-如何判断整型运算溢出/","link":"","permalink":"https://abc.hey-world.xyz/2017/08/04/C-如何判断整型运算溢出/","excerpt":"","text":"整数在计算机中主要由补码表示，分为无符号整数和有符号整数。若用i位表示整数，无符号整数的范围 $[0 , 2^i - 1]$ ，有符号整数的范围 $ [- 2 ^ {i-1} , 2^{i-1} - 1 ]$ 阅读：整数在计算机中的表示 针对32位整型讨论 加法无符号整型溢出舍去一位，相当于$ a+b - 2^i$ ，有 a+b &lt; a 或者 a+b &lt; b 。 更长的临时变量保存 int is_overflow_add_for_unsigned_int( unsigned int a, unsigned int b ) { long sum = a + b; return a + b &lt; a || a + b &lt; b; } 另一种 int is_overflow_add_for_unsigned_int( unsigned int a, unsigned int b ) { return UINT_MAX - a &lt; b; } 有符号整型只有正溢出、负溢出两种情况。 int is_overflow_add_for_signed_int( int a, int b ) { int sum = a + b; if (a > 0 &amp;&amp; b > 0 &amp;&amp; sum &lt; 0) return 1; if (a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; sum > 0) return 1; return 0; } int is_overflow_add_for_signed_int( int a, int b ) { return a >= 0 ? INT_MAX - a &lt; b : INT_MIN - a > b; } 乘法int is_overflow_multiply_for_signed_int(int a,int b){ int mul=a*b; return !a||mul/a==b; } int is_overflow_multiply_for_unsigned_int( unsigned int a, unsigned int b ) { return a == 0 ? 0 : UINT_MAX / a &lt; b; } int is_overflow_multiply_for_signed_int( int a, int b ) { return a == 0 ? 0 : a > 0 &amp;&amp; b > 0 || a &lt; 0 &amp;&amp; b &lt; 0 ? INT_MAX / a &lt; b : INT_MIN / a > b; } 赋值判断溢出先用大一倍位长的临时变量保存，然后再看看截断后跟原值是不是一样。 long y = x * 10 + x % 10; int res = y; if(res == y) return 0; else return 1; 参考 如何判断整型算术运算是否溢出 两个int变量相乘如何判断溢出？","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://abc.hey-world.xyz/tags/C/"},{"name":"溢出","slug":"溢出","permalink":"https://abc.hey-world.xyz/tags/溢出/"}]},{"title":"博客常用","slug":"hexo博客中编辑LaTex公式","date":"2017-06-30T16:31:28.000Z","updated":"2018-07-27T11:41:55.177Z","comments":true,"path":"2017/07/01/hexo博客中编辑LaTex公式/","link":"","permalink":"https://abc.hey-world.xyz/2017/07/01/hexo博客中编辑LaTex公式/","excerpt":"集合多文，方便查看","text":"集合多文，方便查看 hexo命令s 启动服务器hexo g 生成静态文件hexo d 部署hexo new &quot;文章名&quot; 新建文章hexo clean 清除缓存文件和生成的静态文件markdown语法markdown语法编辑 粗体 斜体 删除 分割线 标题 # 一级标题## 二级标题……###### 六级标题 列表、表格 无序 列表 有序 列表 Tables （靠左） Are （居中） Cool （靠右） col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 引用、代码 引用 行内标记 多行代码 图片、链接 text LaTex 数学公式脚本&lt;script type=\"text/javascript\" src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default\">&lt;/script> 公式 行内公式 $y=x$ 整行公式 $$y=x$$ 语法 上标 x^2 x^{31} （注：{}用于分组） 下标 x_2 markdown与hexo自带的marked产生的语法冲突手动加转义符\\ 符号 markdown hexo-render-marked _ 两个\\_之间，表示强调 下标 * 两个\\*之间，表示斜体 乘号 其他与 sublime text 插件 Markdown Preview配合使用自动间隔刷新，文章中插入如下： &lt;meta http-equiv=&quot;refresh&quot; content=&quot;0.1&quot;&gt; 参考hexo指令Markdown——入门指南Markdown进阶语法整理Hexo下mathjax的转义问题","categories":[{"name":"博客","slug":"博客","permalink":"https://abc.hey-world.xyz/categories/博客/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://abc.hey-world.xyz/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://abc.hey-world.xyz/tags/博客/"}]},{"title":"决策树之ID3","slug":"决策树之ID3","date":"2017-06-08T08:28:27.000Z","updated":"2018-07-27T11:41:55.180Z","comments":true,"path":"2017/06/08/决策树之ID3/","link":"","permalink":"https://abc.hey-world.xyz/2017/06/08/决策树之ID3/","excerpt":"","text":"概念决策树是一棵多叉树，每个非叶子节点用一个输入特征标记，每个分支用该特征的一个可能值标记，每个叶节点用类别的一个元素标记。 决策树算法，在训练阶段，用样本数据构造一棵决策树，作为分类器。学习的结果是一个决策树。 两个问题什么样的特征分类能力最好？采用熵，作为系统无序化程度的度量。信息熵：信源不确定度。$ H \\left (U \\right) = E \\left [ - \\log p_{i} \\right ] = - \\sum_{i=1}^{n} p_{i} \\log p_{i} $值得注意的是，信息集合的体量越大，熵也越大。所以用集合中样本数量的占比来为集合加权，引入信息增益。 信息增益：特征给系统带来的信息量。熵减 = 信息增$ IG \\left ( S , T \\right) = E \\left( S \\right ) - \\sum_{i=0}^{N} \\frac{D_{i}}{D_{S}} E \\left( S_{i} \\right) $ 延伸 互信息 ：变量间相互依赖性的量度知道其中一个变量提供的另一个的信息量（即不确定度的减少量）知道 X 后 Y 的不确定度的量的减少程度 = Y的不确定度 - 在 X 已知之后 Y 的剩余不确定度的量 怎样的结点是叶子结点？ 情况 判断条件 纯结点 $ \\max IG = 0 $ 非纯结点，而且当前所有的特征都测试完 $ \\max IG = 0 $ 空结点 样本数 = 0 对于纯叶子结点，若再用任意特征划分：对于纯结点集合S，有两种情况，一是样本全属于某类别$ p_{i} = 1 $，则$ \\log_{2} p_{i} = 0 $；一是$ p_{i} = 0 $。此时再用任一特征把S划分为k个子集合$ S_{1},S_{2},…,S_{k} $，全是纯结点，信息熵为零，故$ IG \\left ( S , T \\right) = E \\left( S \\right ) - \\sum_{i=0}^{k} \\frac{D_{i}}{D_{S}} E \\left( S_{i} \\right) = 0 $ 对于非纯叶结点，所有特征测试完，再选任一特征进行划分：相当于重复测试特征，得到的子集合 = 父集合。","categories":[{"name":"模式识别","slug":"模式识别","permalink":"https://abc.hey-world.xyz/categories/模式识别/"}],"tags":[{"name":"有监督学习","slug":"有监督学习","permalink":"https://abc.hey-world.xyz/tags/有监督学习/"}]},{"title":"人工神经网络之BP算法","slug":"人工神经网络之BP算法","date":"2017-06-06T14:23:21.000Z","updated":"2018-07-27T11:41:55.178Z","comments":true,"path":"2017/06/06/人工神经网络之BP算法/","link":"","permalink":"https://abc.hey-world.xyz/2017/06/06/人工神经网络之BP算法/","excerpt":"","text":"相关概念神经网络，是一种应用类似于大脑神经突触连接结构进行信息处理的数学模型。一个神经元包含一个细胞体、一些树突和一根很长的轴突。 如何模拟大脑神经元之间有权重的链接将信号从一个神经元传递到另一个神经元。每个神经元连接到几个输入信号，但不会产生多于一个输出信号。（输入层不算。一层中间层+输出层=两层神经网络） 人工神经网络ANN，是一个非线性有向无环图。神经元的信号强弱——分支不分流。 生物 人工 细胞体 神经元 树突 输入 轴突 输出 突触 权重 如何学习神经元通过链接相连，每个链接都有权重。学习的是权重。 发展萌芽期 MP模型 阈值加权和 $ 一个神经元 = \\sum_{i=0}^{N} 强度 * 权重 - 抑制能力 $ 第一次高潮 Perceptron 单级感知器 一层的神经网络（没有中间层，只能解决线性问题） 第二次高潮 Hopfield网络 Boltzmann机 BP算法 BP算法","categories":[{"name":"模式识别","slug":"模式识别","permalink":"https://abc.hey-world.xyz/categories/模式识别/"}],"tags":[{"name":"有监督学习","slug":"有监督学习","permalink":"https://abc.hey-world.xyz/tags/有监督学习/"}]},{"title":"这些电脑小工具","slug":"这些电脑小工具","date":"2017-03-07T09:38:38.000Z","updated":"2019-04-24T14:28:05.941Z","comments":true,"path":"2017/03/07/这些电脑小工具/","link":"","permalink":"https://abc.hey-world.xyz/2017/03/07/这些电脑小工具/","excerpt":"写于2017-03-07 2019-04-24更新 这是一篇正经的安利小文，关于电脑上的一些小工具，特别分享给二狗和二二同学~ 在电脑上各种软件或网站，总会遇到挺多的限制，这时候喜欢找些奇奇怪怪的东西，帮自己提高提高效率，而且，发现新事物的过程也是特别愉快，每次都惊叹于人民群众的劳动智慧。","text":"写于2017-03-07 2019-04-24更新 这是一篇正经的安利小文，关于电脑上的一些小工具，特别分享给二狗和二二同学~ 在电脑上各种软件或网站，总会遇到挺多的限制，这时候喜欢找些奇奇怪怪的东西，帮自己提高提高效率，而且，发现新事物的过程也是特别愉快，每次都惊叹于人民群众的劳动智慧。 原始人制作了石锤、石斧等，技能满点，想方设法合作把许多有威胁的大型动物团灭，过上喝酒吃肉的快意生活。当然，只会专注于收集工具而不用，也就是个摆设罢。 工具的来源或教程，大多来自度娘、知乎、吾爱论坛，此处不表，自行百度咯。 软件远程&amp;命令行putty连接服务器 gitteamviewer可以ipad控制电脑 Cmder好用的命令行 xftpftp 学习PDF-Viewerpdf阅读器，轻量，支持自定义快捷键添加笔记。NICE Xmind思维导图 Citavi论文管理 Visio画图 OneDrive资料同步 OneNote——笔记整理以前用印象笔记，奈何断断续续出问题，登录失败，弃之。如果电脑装了Office，已经顺带装好了OneNote桌面版。 按Tab键自动生成表格 可自定义标记+配合快捷键 自由移动一大块 绘图功能，配合可触屏的笔记本更佳 可以找插件，如代码高亮 复制文字，粘贴转图片 插入文件、音频等…… 笔记本分区无限（笔记本里的笔记本里的……笔记）等等~ ##英语 Aboboo可练习英语听写、跟读。 MDict词典，可自行添加各种词典。 Anki——单词记忆工具，自制词库（不只限制于单词）。有正反卡片，填空等格式 写博客Typoramarkdown编辑器 PicGo图床工具 PotPlayer &amp; VLC——播放器支持倍速播放，看视频课加快语速 QQ影音Mp4转Mp3格式 小工具日常操作Everything查找文件，非常快。 Snipaste截图，且截图可编辑加文字等。 DeskPins窗口置顶。配合chrome插件separate window可以边看小窗看视频边干活。 Ditto复制粘贴工具，支持多次复制，选择性粘贴。 SnapTimer倒计时 Sticky NotesWin10自带便签 Rocket Dock模仿linux底部菜单 系统监控CCleaner电脑清洁 Speccy64硬件监控 视频下载 b站 ——在网址bilibili前面加i或后面加jj，可跳转 爱课程网 ——爱课程课程助手地瓜专版 网易公开课 ——网易云课堂课程下载器v2.2配合PotPlayer，棒(●’◡’●)音乐 集合下载工具 ——音乐间谍V3.4 配合网易云音乐，上传到我的音乐云盘，电脑手机同步听。 Spotify： 调教一段时间后，推荐很合口味。适合在线听歌，免费版只能随机打乱听。有安卓端。 ChromeChrome插件Momemtun——漂亮的标签页 LastPass——管理密码 Clip to OneNote——配合OneNote的剪切工具 OneTab——把暂时不用的标签页变成一个，节省内存。对于喜欢一次打开十几个标签页的我，福音！！ 一键管理所有拓展——快速禁用插件 EyeDropper——网页取色工具强迫症用ps时的福音 Violent Monkey——脚本管理 配合某脚本+迅雷破解版，用迅雷下载百度云的大文件，具体搜知乎 Diigo网页摘录 Chrome应用Gliffy Diagrams——画流程图等 Halo Word——词典，按Ctrl查词 Postman发送http请求","categories":[{"name":"随笔","slug":"随笔","permalink":"https://abc.hey-world.xyz/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://abc.hey-world.xyz/tags/随笔/"}]}]}