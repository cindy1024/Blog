{"meta":{"title":"安静土","subtitle":"Glad You Came","description":"一只蘑菇","author":"蘑蘑蘑的菇","url":"https://abc.hey-world.xyz"},"pages":[{"title":"About me","date":"2018-07-27T09:44:21.000Z","updated":"2020-05-02T06:59:22.297Z","comments":true,"path":"about/index.html","permalink":"https://abc.hey-world.xyz/about/index.html","excerpt":"","text":"CS在读，爱好羽毛球 日志 2020-04-30：更换github图床+jsdelivr加速 ；源码同步托管coding和github，智能dns设置境内境外不同访问线路，cloudflare加速；valine评论通知。 2019-03-23：更换域名，更新不蒜子统计，更换又拍云图床，添加文章底部版权样式。 2018-07-27：启用Next主题，自定义样式克隆自CHANGE・業・德，表示感谢 2017-07-24：启用主题Material 2017-02-01：建博"},{"title":"categories","date":"2018-07-27T09:41:59.000Z","updated":"2018-07-28T09:11:00.066Z","comments":false,"path":"categories/index.html","permalink":"https://abc.hey-world.xyz/categories/index.html","excerpt":"","text":""},{"title":"写啊！少年","date":"2020-02-10T04:10:11.049Z","updated":"2019-04-27T08:14:48.231Z","comments":true,"path":"mind/index.html","permalink":"https://abc.hey-world.xyz/mind/index.html","excerpt":"","text":"句"},{"title":"翻完我的简讯我的信 顺便翻翻我的心情","date":"2017-11-06T10:01:31.000Z","updated":"2018-01-16T14:42:14.482Z","comments":true,"path":"mind/翻完我的简讯我的信-顺便翻翻我的心情.html","permalink":"https://abc.hey-world.xyz/mind/翻完我的简讯我的信-顺便翻翻我的心情.html","excerpt":"","text":"2017.11.09 天气 晴 从网易云转战虾米，开始拾起很久没听的林宥嘉。熟悉的感觉，神游live的每一首歌似乎都那么熟悉。在学校广播听见yoga，开心得可以蹦起来，享受。"},{"title":"Digit Generator","date":"2017-08-17T07:53:17.000Z","updated":"2017-08-17T07:53:34.292Z","comments":true,"path":"questions/Digit-Generator.html","permalink":"https://abc.hey-world.xyz/questions/Digit-Generator.html","excerpt":"生成元。","text":"生成元。 题目 1583如果x加上x的各个数字之和等于y，就说x是y的生成元。245是256 (= 245 + 2 + 4 + 5)的生成元。 有的数字没有生成元，有的数字不止一个（找到最小的）。 InputYour program is to read from standard input. The input consists of T test cases. The number of test cases T is given in the first line of the input. Each test case takes one line containing an integer N, 1 ≤ N ≤ 100, 000. OutputYour program is to write to standard output. Print exactly one line for each test case. The line is to contain a generator of N for each test case. If N has multiple generators, print the smallest. If N does not have any generators, print ‘0’. Sample Input3 216 121 2005 Sample Output198 0 1979 分析遍历N-1个数效率低，利用 y - x数字之和 = x ，对于y，判断 (y - sum)的数字之和与sum是否相等。首先要求y的位数n，sum的最大可能为 n * 9（x由n个9组成）。 解决#include &lt;iostream> using namespace std; int getDigit(int x) { int nDigit = 1; while (x) { x /= 10; nDigit++; } return nDigit; } int getSumDigit(int x) { int sum = 0; while (x) { int tmp = x % 10; sum += tmp; x /= 10; } return sum; } int main() { int c; while (cin >> c) { int x; for (int k = 0;cin >> x &amp;&amp; k &lt; c; k++) { int n = getDigit(x); int res = 0; for (int i = 9 * n; i >= 0; i--) { if (i == getSumDigit(x - i) ) { res = x - i; break; } } cout &lt;&lt; res &lt;&lt; endl; } } return 0; } 参考刘汝佳的做法：枚举100000内所有正整数x，计算y，生成表。要用时查表 其他快速取得一个整数的最高位查资料过程看到，只有一点相关，但要记录每一位的情况下还是老办法好。 最佳：Unrolled &amp; optimized loop if (i >= 100000000) i /= 100000000; if (i >= 10000) i /= 10000; if (i >= 100) i /= 100; if (i >= 10) i /= 10;"},{"title":"Master-Mind Hints","date":"2017-08-15T13:25:44.000Z","updated":"2019-04-27T08:14:53.493Z","comments":true,"path":"questions/Master-Mind-Hints.html","permalink":"https://abc.hey-world.xyz/questions/Master-Mind-Hints.html","excerpt":"猜数字游戏的提示。","text":"猜数字游戏的提示。 题目 340猜数字游戏，给定用户序列a secret code和答案序列guesses，统计有多少数字位置正确（A）a strong match，多少数字在两个序列都出现过但位置不对（B）a weak match。 输入第一行为序列长度n，第二行为答案序列，接下来是猜测序列。猜测序列为全零，该组数据结束；n=0时输入结束。（数字1~9） s[i]==p[j] 且 i==j 时, a strong matchs[i]==p[j] 且 i!=j 时, a weak match Sample Input Sample Output注意输入格式，序列前面有4个空格 orz… 分析起初思维被限定，按照count流程一个个计算，要考虑很多情况，非常麻烦。 参考刘汝佳思路：直接统计可得A。为了求B，对每个数字，统计在二者出现的次数c1和c2，min(c1, c2)是该数字对B的贡献。最后的最后减去A的部分。 用数组a、b分别统计每个数字在两序列出现次数。 解决#include &lt;string.h> #include &lt;iostream> using namespace std; int main() { int n; int game = 0; int a[10] = { 0 }; while (cin >> n) { if (n == 0) break; int *num = new int[n]; for (int i = 0; i &lt; n; i++) { int x; cin >> x; num[i] = x; a[x]++; } cout &lt;&lt; \"Game \" &lt;&lt; ++game &lt;&lt; \":\" &lt;&lt; endl; while (1) { int b[10] = { 0 }; int zero,correct, dislocate; //输入0的个数、A个数、B个数 zero = correct = dislocate = 0; for (int i = 0; i &lt; n; i++) { int x; cin >> x; b[x]++; if (x == 0) zero++; if (x == num[i]) correct++; } if (zero == n) break; for (int i = 1; i &lt; 10; i++) { dislocate += a[i] &lt;= b[i] ? a[i] : b[i]; } dislocate -= correct; cout &lt;&lt; '(' &lt;&lt; correct &lt;&lt; ',' &lt;&lt; dislocate &lt;&lt; ')' &lt;&lt; endl; } memset(a, 0, sizeof(a)); delete[] num; } return 0; }"},{"title":"Palindrome Number","date":"2017-08-08T09:11:18.000Z","updated":"2017-08-12T15:08:37.155Z","comments":true,"path":"questions/Palindrome-Number.html","permalink":"https://abc.hey-world.xyz/questions/Palindrome-Number.html","excerpt":"判断回文数。","text":"判断回文数。 题目 9Determine whether an integer is a palindrome. Do this without extra space. click to show spoilers. Some hints:Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case? There is a more generic way of solving this problem. 分析负号不对称，负数不是回文数。 解决用了额外的栈和队列空间。 bool isPalindrome(int x) { if (x &lt; 0) return false; stack&lt;int> s; queue&lt;int> q; while (x != 0) { int tmp = x % 10; s.push(tmp); q.push(tmp); x /= 10; } while (s.size()) { if (s.top() == q.front()) { s.pop(); q.pop(); } else return false; } return true; } 参考Only reversing till half and then compare. 007-Reverse-Integer 空间复杂度O(1)，与问题规模n无关。 bool isPalindrome(int x) { if(x&lt;0|| (x!=0 &amp;&amp;x%10==0)) return false; //10的倍数必定不是回文数 int sum=0; while(x>sum) { sum = sum*10+x%10; x = x/10; } return (x==sum)||(x==sum/10); //偶数位、奇数位 }"},{"title":"Palindrome Number","date":"2017-08-12T09:44:44.000Z","updated":"2017-08-15T16:21:55.142Z","comments":true,"path":"questions/Palindromes.html","permalink":"https://abc.hey-world.xyz/questions/Palindromes.html","excerpt":"判断字符串是否为回文串或镜像串。","text":"判断字符串是否为回文串或镜像串。 题目 401InputInput consists of strings (one per line) each of which will consist of one to twenty valid characters.There will be no invalid characters in any of the strings. Your program should read to the end of file. OutputFor each input string, you should print the string starting in column 1 immediately followed by exactly one of the following strings. Sample InputNOTAPALINDROMEISAPALINILAPASI2A3MEASATOYOTA Sample OutputNOTAPALINDROME – is not a palindrome.ISAPALINILAPASI – is a regular palindrome.2A3MEAS – is a mirrored string.ATOYOTA – is a mirrored palindrome. Note ‘0’ (zero) and ‘O’ (the letter) are considered the same character and therefore ONLY the letter ‘O’ is a valid character. The output line is to include the ‘-’s and spacing exactly as shown in the table above and demonstrated in the Sample Output below. In addition, after each output line, you must print an empty line. 分析依次首尾比较。 解决用string数组存储输出信息，用p * 2 + m计算标志位来输出信息。 #include &lt;string> #include &lt;iostream> using namespace std; const string reverse = \"A 3 HIL JM O 2TUVWXY51SE Z 8 \"; const string message[4] = { \"not a palindrome\",\"a mirrored string\",\"a regular palindrome\",\"a mirrored palindrome\" }; char mirror(char ch) { if (ch >= 'A' &amp;&amp; ch &lt;= 'Z') return reverse[ch - 'A']; if (ch >= '0' &amp;&amp; ch &lt;= '9') return reverse[ch - '0' + 25]; } int main() { string s; while(cin >> s) { bool p, m; p = m = true; int len = s.size(); for (int i = 0; i &lt; len; i++) { if (s[i] != s[len - i - 1]) p = false; if (s[i] != mirror(s[len - i - 1])) m = false; } cout &lt;&lt; s &lt;&lt; \" -- is \" &lt;&lt; message[p * 2 + m] &lt;&lt; \".\" &lt;&lt;endl &lt;&lt;endl; } return 0; }"},{"title":"Reverse Integer","date":"2017-08-03T04:31:08.000Z","updated":"2017-11-21T13:33:12.272Z","comments":true,"path":"questions/Reverse-Integer.html","permalink":"https://abc.hey-world.xyz/questions/Reverse-Integer.html","excerpt":"翻转32位有符号整型数字，注意溢出。","text":"翻转32位有符号整型数字，注意溢出。 题目 7Reverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321 Note: The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows. 分析 32位有符号整型范围：$[-2^{31} , 2^{31}-1]$ 溢出 int y = a*b; 在得出a*b的结果时已经溢出（在赋值之前） 解决int reverse(int x) { const int max = pow(2, 31) - 1; if (x > max || x &lt; -max - 1) return 0; double y = 0; while( x != 0) { double tmp = y * 10 + (x % 10); y = (tmp > max || tmp &lt; -max - 1) ? 0:tmp; //判断溢出 x /= 10; } return (int)y; } 参考主体过程一样，区别在于对溢出的处理： 用long保存中间转换数 long赋值给int，若赋值后两边不等，溢出。 class Solution { public: int reverse(int x) { long long numReversed = 0; //长整型64位 int num = x; while ( num != 0 ) { numReversed = numReversed * 10 + num % 10; num /= 10; } int y = numReversed; if (y == numReversed) return y; else return 0; } }; something数的表示 科学计数法 2E31 =&gt; $2* (10^{31})$ 次方的表示 pow(2,31) =&gt; $2^{31}$ （注：头文件&lt;math.h&gt;） 如何判断溢出"},{"title":"String to Integer","date":"2017-08-03T11:02:17.000Z","updated":"2017-08-12T15:08:19.345Z","comments":true,"path":"questions/String-to-Integer.html","permalink":"https://abc.hey-world.xyz/questions/String-to-Integer.html","excerpt":"实现atoi函数。","text":"实现atoi函数。 题目 8Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. 分析 atoi (ascii to integer)把字符串转换成整型数。跳过前面的空白字符（例如空格，tab缩进等。可以通过isspace( )函数来检测），直到遇上数字或正负符号才开始做转换，而在遇到非数字或字符串结束时(‘\\0’)才结束转换，并将结果返回。如果 nptr不能转换成 int 或者 nptr为空字符串，那么将返回 0。 题目说明包含所有输入情况，需要考虑： 开头过滤空白字符 isspace( )函数 符号位 顺序 ${(blank character)}^{*} {(+|-)}^{*} {(num)}^{*}$ 溢出 无效输入 连着2个符号位及以上 “+ 123” 奇葩输入： “ 001” “18446744073709551617” 解决可改进： 过滤符号位麻烦，类似’+-‘情况直接放最后考虑。 判断溢出 最终处理符号位 * int myAtoi(string str) { int num = 0; int flag = 0; //记录符号位 int i,start; bool overflow = false; //溢出标志 for (i = 0; isspace(str[i]); i++) {} //过滤空白符 start = i; // for (; i &lt; str.length(); i++) { //过滤'+'、'-' if (str[i] == '+') flag++; else if (str[i] == '-') flag--; else break; } for (; i &lt; str.length(); i++) { if (str[i] >= '0' &amp;&amp; str[i] &lt;= '9') { //num = num * 10 + str[i] - 48; int tmp = num * 10; if (tmp / 10 != num) //乘法溢出 overflow = true; num = tmp + str[i] - 48; if (overflow == false &amp;&amp; num &lt; 0) overflow = true; //加法溢出 if (i == start) flag = 1; //没有'+'、'-'符号出现 } else break; } switch (flag) { case 1: if (overflow) return INT_MAX; else return num; case -1: if (overflow) return INT_MIN; else return -1 * num; default: return 0; } } 参考 用i++连接三个过程 对溢出的判断 INT_MIN -2147483648 被误判为overflow，但结果恰好正确。 int atoi(const char *str) { int sign = 1, base = 0, i = 0; while (str[i] == ' ') { i++; } if (str[i] == '-' || str[i] == '+') { sign = 1 - 2 * (str[i++] == '-'); //先赋值再++ } while (str[i] >= '0' &amp;&amp; str[i] &lt;= '9') { //判断溢出 if (base > INT_MAX / 10 || (base == INT_MAX / 10 &amp;&amp; str[i] - '0' > INT_MAX % 10)) { if (sign == 1) return INT_MAX; else return INT_MIN; } base = 10 * base + (str[i++] - '0'); } return base * sign; } something INT_MAX等范围值在&lt;limits.h&gt;文件中。 判断溢出"},{"title":"ZigZag Conversion","date":"2017-08-03T03:05:31.000Z","updated":"2017-08-12T15:08:26.980Z","comments":true,"path":"questions/ZigZag-Conversion.html","permalink":"https://abc.hey-world.xyz/questions/ZigZag-Conversion.html","excerpt":"把字符串转换成之字形，重新读取字串。","text":"把字符串转换成之字形，重新读取字串。 题目 6The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H N A P L S I I G Y I R And then read line by line: &quot;PAHNAPLSIIGYIR&quot;Write the code that will take a string and make this conversion given a number of rows: string convert(string text, int nRows); convert(&quot;PAYPALISHIRING&quot;, 3) should return &quot;PAHNAPLSIIGYIR&quot;. 分析找规律题 解决每行的首字母之后都依次分析第一个字母(nRows-1-i)*2、第二个字母(nRows-1)*2，繁琐。 string convert(string text, int nRows) { int l_space, r_space, l_letter, r_letter; int t; string res; if(nRows == 1) return text; for (int i = 0; i &lt; nRows; i++) { l_letter = (nRows - 1 - i) * 2; r_letter = 2 * i; t = i; res.push_back(text[t]); while (t + l_letter &lt; text.length()) { if (l_letter != 0) res.push_back(text[t + l_letter]); if (t + (nRows - 1) * 2 >= text.length()) break; //若第二个字母超出范围，本行已经到末尾 if (r_letter != 0) res.push_back(text[t + l_letter + r_letter]); t = t + (nRows - 1) * 2; //更新某行的当前标记 if (t == 0) break; //只有一个字符 } } return res; } 参考间隔列固定 2*numRows-2，（除了首行和末尾行）中间字母规律2*(numRows-1-i)。 class Solution { public: string convert(string s, int numRows) { if(numRows==1) return s; string rel=\"\"; int l=s.length(); int add=2*numRows-2; for(int i=0;i&lt;numRows;i++){ for(int j=i;j&lt;l;j+=add){ //把步长增加放到for循环中 rel+=s[j]; //固定列字母 int flag=j+2*(numRows-1-i); if(i!=0&amp;&amp;i!=numRows-1&amp;&amp;flag&lt;l){ //非首尾行，且 flag&lt;l rel+=s[flag]; //中间字母 } } } return rel; } };"},{"title":"Container With Most Water","date":"2017-11-09T07:13:18.000Z","updated":"2017-11-09T07:25:30.329Z","comments":true,"path":"questions/container-with-most-water.html","permalink":"https://abc.hey-world.xyz/questions/container-with-most-water.html","excerpt":"装最多水的容器。","text":"装最多水的容器。 题目 11Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. 给定 n 个非负整数 a1, a2, …, an, 每个数代表了坐标中的一个点 (i, ai)。画 n 条垂直线，使得 i 垂直线的两个端点分别为(i, ai)和(i, 0)。找到两条线，使得其与 x 轴共同构成一个容器，以容纳最多水。 分析一开始看到题目有些发懵，反复读了几遍，其实就是 木桶效应+最大长方形 问题的结合。两条直线中，较短的一条成为短板。用两个指针分别从左右开始往中间走，希望继续寻找比短板更高的直线。过程比较简单。 解决 int maxArea(vector&lt;int>&amp; height) { int maxArea = 0; int area = 0; int i = 0; int j = height.size() - 1; while (i &lt; j) { if (height[i] &lt;= height[j]) { area = (j - i)*height[i]; //计算面积 i++; //左边指针往中间走 } else { area = (j - i)* height[j]; //计算面积 j--; //右边指针往中间走 } if (area > maxArea) maxArea = area; } return maxArea; }"},{"title":"奋起啊！少年","date":"2020-05-08T14:06:43.734Z","updated":"2020-05-08T14:06:43.734Z","comments":true,"path":"questions/index.html","permalink":"https://abc.hey-world.xyz/questions/index.html","excerpt":"","text":"题库leetcode 006 ZigZag Conversion 把字符串转换成之字形，重新读取字串。 007 Reverse Integer 翻转32位有符号整型数字，注意溢出。 008 String to Integer 实现atoi函数。 009 Palindrome Number 判断回文数。 011 Container With Most Water 木桶效应+最大长方形。 012/013 Integer to Roman / Roman to Integer 整型、罗马数字互转。 014 Longest Common Prefix 最长共同前缀。 021 合并两个有序链表 083 删除排序链表中的重复元素 141/142 环形链表 160 相交链表 203 移除链表元素 98 验证二叉搜索树 983 最低票价 572 另一个树的子树 221/1277 最大正方形/统计全为1的正方形子矩阵 509/70 斐波那契数/爬楼梯 UVa 0401 Palindromes 判断回文串或镜像串。 0340 Master-Mind Hints 猜数字游戏的提示。 1583 Digit Generator 生成元。 剑指Offer 002 实现Singleton模式 一个类只产生一个实例。 003 数组中的重复数字 找出数组中任意一个重复的数字。 004 二维数组中的查找 有序二维数组中查找一个数字。 005 替换空格 替换字符串中的每个空格。 006 从尾到头打印链表 分类String leetcode - 006 ZigZag Conversion leetcode - 008 String to Integer UVa - 0401 Palindromes leetcode - 012/013 Integer to Roman / Roman to Integer leetcode - 014 Longest Common Prefix 最长共同前缀。 剑指offer - 005_替换空格 替换字符串中的每个空格。 Math leetcode - 007 Reverse Integer leetcode - 008 String to Integer leetcode - 009 Palindrome Number UVa - 0340 Master-Mind Hints UVa - 1583 Digit Generator leetcode - 012 Integer to Roman Array leetcode - 011 Container With Most Water 剑指offer - 003 数组中的重复数字 找出数组中任意一个重复的数字。 剑指offer - 004 二维数组中的查找 有序二维数组中查找一个数字。 List 剑指offer - 006 从尾到头打印链表 leetcode - 021 合并两个有序链表 leetcode - 083 删除排序链表中的重复元素 leetcode - 141/142 环形链表 leetcode - 160 相交链表 leetcode - 203 移除链表元素 Design pattern 剑指offer - 002 实现Singleton模式 Tree leetcode - 98 验证二叉搜索树 leetcode - 572 另一个树的子树 DP leetcode - 983 最低票价 leetcode - 221/1277 最大正方形/统计全为1的正方形子矩阵 leetcode - 509/70 斐波那契数/爬楼梯"},{"title":"Integer to Roman / Roman to Integer","date":"2017-11-09T08:44:09.000Z","updated":"2017-11-21T13:39:17.308Z","comments":true,"path":"questions/integer-to-roman.html","permalink":"https://abc.hey-world.xyz/questions/integer-to-roman.html","excerpt":"整型、罗马数字互转。","text":"整型、罗马数字互转。 题目 12Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. 题目 13Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 分析摸清罗马数字的规律。罗马数字wiki index 0 1 2 3 4 5 6 Roman I V X L C D M value 1 5 10 50 100 500 1000 t = 1, 3, 5 个位与IVX有关，十位与XLC有关，百位与CDM有关。 余数 该位对应的罗马数字 0 1 - 3 (t-1)…(t-1) 4 (t-1)(t) 5 - 8 (t)(t+1)…(t+1) 9 (t-1)(t+1) 解决Int To Roman：根据数字符号的对应规律，从高位数字开始转换 string intToRoman(int num) { char roman[7] = {'I','V','X','L','C','D','M'}; int t = 1; string res = \"\"; do { string str = \"\"; int x = num % 10; if (!x) { t += 2; num /= 10; continue; } if (x &lt; 4) for (int i = 0; i &lt; x; i++) str += roman[t - 1]; if (x == 4) { str += roman[t - 1]; str += roman[t]; } if (x > 4 &amp;&amp; x &lt; 9) { str += roman[t]; for (int i = 0; i &lt; x - 5; i++) str += roman[t - 1]; } if (x == 9) { str += roman[t - 1]; str += roman[t + 1]; } t += 2; num /= 10; res.insert(0, str); //把每一位求得的编码从头插入，不然会倒序 } while (num); return res; } Roman To Int：一个个字符地转成数字意义 int romanToInt(string s) { int res = 0; unordered_map&lt;char, int> map; map['I'] = 1; map['V'] = 5; map['X'] = 10; map['L'] = 50; map['C'] = 100; map['D'] = 500; map['M'] = 1000; bool start = true;// int i = 1; for (; i &lt; s.size(); i++) { res += toInt(map[s[i - 1]], map[s[i]], start); } if(start) res += map[s[i - 1]]; return res; } int toInt(int a, int b, bool &amp;start) { int t = 0; if (a >= b &amp;&amp; a / b &lt; 10) { t += b; if (start) { t += a; } start = false; } else if (b > a) { t += b - a; start = false; } else if (start) t += a; else start = true; return t; }"},{"title":"Longest Common Prefix","date":"2017-11-21T13:16:44.000Z","updated":"2017-11-21T13:39:15.002Z","comments":true,"path":"questions/longest-common-prefix.html","permalink":"https://abc.hey-world.xyz/questions/longest-common-prefix.html","excerpt":"最长共同前缀。","text":"最长共同前缀。 题目 14Write a function to find the longest common prefix string amongst an array of strings. 分析 横向看 （先数组，再看列）$LCP(S{1}…S{n})=LCP(LCP(LCP(S{1},S{2}),S{3}),…S{n})$ 纵向看（先看列，再数组） 解决纵向 string longestCommonPrefix(vector&lt;string>&amp; strs) { string str = \"\"; if (strs.size() == 0) return str; for (int i = 0; i &lt; strs[0].size(); i++) { //每一列 char ch = strs[0][i]; bool flag = true; for (int j = 1; j &lt; strs.size(); j++) { //数组（相当于行） if (ch != strs[j][i]) { flag = false; //用标记记录进程，改进见参考 break; } } if (flag) str += ch; else break; } return str; } 参考横向 public String longestCommonPrefix(String[] strs) { if (strs.length == 0) return \"\"; String prefix = strs[0]; for (int i = 1; i &lt; strs.length; i++) while (strs[i].indexOf(prefix) != 0) { prefix = prefix.substring(0, prefix.length() - 1); if (prefix.isEmpty()) return \"\"; } return prefix; } 纵向 public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) return \"\"; for (int i = 0; i &lt; strs[0].length() ; i++){ char c = strs[0].charAt(i); for (int j = 1; j &lt; strs.length; j ++) { if (i == strs[j].length() || strs[j].charAt(i) != c) return strs[0].substring(0, i); //flag改进成 } } return strs[0]; } 另一种想法：从长到短。先假设prefix为第一个串，依次比较其他串，改变prefix的位数。 string longestCommonPrefix(vector&lt;string>&amp; strs) { if (strs.size() == 0) { return \"\"; } string prefix = strs[0]; for (int i = 1; i &lt; strs.size(); i++) { while (0 != strs[i].compare(0, prefix.length(), prefix)) { prefix = prefix.substr(0, prefix.length()-1); } } return prefix; }"},{"title":"","date":"2020-02-11T07:48:00.000Z","updated":"2020-02-11T07:51:47.686Z","comments":true,"path":"questions/模板.html","permalink":"https://abc.hey-world.xyz/questions/模板.html","excerpt":"","text":"题目 0"},{"title":"tags","date":"2018-07-27T09:42:54.000Z","updated":"2018-07-28T09:11:36.162Z","comments":false,"path":"tags/index.html","permalink":"https://abc.hey-world.xyz/tags/index.html","excerpt":"","text":""},{"title":"timeline","date":"2020-02-10T04:10:26.880Z","updated":"2017-08-11T02:13:48.473Z","comments":true,"path":"timeline/index.html","permalink":"https://abc.hey-world.xyz/timeline/index.html","excerpt":"","text":""},{"title":"另一个树的子树","date":"2020-05-06T16:00:00.000Z","updated":"2020-05-08T13:07:03.079Z","comments":true,"path":"questions/leetcode/另一个树的子树.html","permalink":"https://abc.hey-world.xyz/questions/leetcode/另一个树的子树.html","excerpt":"","text":"题目 572 题解DFS暴力匹配DFS枚举s的每个节点，其子树判断与t是否相等。需要有一个指针恒指向t的根，另两个指针在s和t上同步移动。 DFS序列上做串匹配树哈希代码DFS暴力匹配 bool isSubtree(TreeNode* s, TreeNode* t) { if (!s && !t) return true; if (!s && t) return false; return compareSubtree(s,t) || isSubtree(s->left, t) || isSubtree(s->right, t); } bool compareSubtree(TreeNode* s, TreeNode* t) { if (!s && !t) return true; else if (!s || !t) return false; if (s->val == t->val) if( compareSubtree(s->left, t->left) && compareSubtree(s->right, t->right) ) return true; return false; }"},{"title":"删除排序链表中的重复元素","date":"2020-05-01T07:48:00.000Z","updated":"2020-05-02T07:37:57.936Z","comments":true,"path":"questions/leetcode/删除排序链表中的重复元素.html","permalink":"https://abc.hey-world.xyz/questions/leetcode/删除排序链表中的重复元素.html","excerpt":"","text":"题目 83 题解考察链表操作，比较current和next是否相同，相同则跳过next指向next-&gt;next。 代码 ListNode* deleteDuplicates(ListNode* head) { ListNode* p = head; while (p != nullptr && p->next != nullptr){ if(p->val == p->next->val) p->next = p->next->next; else p = p->next; } return head; }"},{"title":"斐波那契数_爬楼梯","date":"2020-05-07T16:00:00.000Z","updated":"2020-05-08T13:53:56.530Z","comments":true,"path":"questions/leetcode/斐波那契数_爬楼梯.html","permalink":"https://abc.hey-world.xyz/questions/leetcode/斐波那契数_爬楼梯.html","excerpt":"","text":"题目 509 斐波那契数 题目 70 爬楼梯 题解暴力法会爆炸，动态规划来一下。 注意：爬楼梯题目，$n=0$时，有1种爬法，就是不爬…….. 动态规划代码509 int fib(int N) { if (N == 0 || N == 1) return N; int* dp = new int[N + 1]; dp[0] = 0; dp[1] = 1; for(int i = 2; i"},{"title":"合并两个有序链表","date":"2020-05-01T07:48:00.000Z","updated":"2020-05-02T07:27:49.846Z","comments":true,"path":"questions/leetcode/合并两个有序链表.html","permalink":"https://abc.hey-world.xyz/questions/leetcode/合并两个有序链表.html","excerpt":"","text":"题目 21 解法递归迭代判断哪个链表的节点更小，依次比较，需要新增一个合并指示指针p。判断完一个链表时，直接把p指向另一个未判断完的链表（更大）即可。 代码迭代 ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(l1 == nullptr) return l2; if(l2 == nullptr) return l1; ListNode* head = new ListNode(-1); ListNode* p; p = head; while(l1 != nullptr && l2 != nullptr ){ if(l1->val val){ p->next = l1; l1 = l1->next; } else { p->next = l2; l2 = l2->next; } p = p->next; } p->next = l1 == nullptr ? l2 : l1; //attention return head->next; }"},{"title":"最低票价","date":"2020-05-05T16:00:00.000Z","updated":"2020-05-08T11:35:36.210Z","comments":true,"path":"questions/leetcode/最低票价.html","permalink":"https://abc.hey-world.xyz/questions/leetcode/最低票价.html","excerpt":"","text":"题目 983 题解题目有最大值一词，是动态规划的特点。 用int dp[366]记录一年中到第i天为止需要花的钱，不出门则当天不需要多花钱。dp[0] = 0作为一个初始状态。 出门，转移方程：$dp(i) = min{cost(index_j)+dp(i-j)}, j\\in{1,7,30}$ 理解一：反思式买票 在第10天看我如果在${第9天买1日票，第3天买7日票，直接买30日票}​$哪个划算 理解二：先旅游后买票 一张4-10天的票，第10天付款。（from评论区） 不出门，则不多花钱：$dp(i) = dp(i-1)​$ 代码 int mincostTickets(vector& days, vector& costs) { int dp[366] = {0}; int a, b, c; int j = 0; for (int i = 1; i < 366; i++) { if (j < days.size() && i == days[j]){ a = costs[0] + dp[i - 1]; b = costs[1] + dp[ i - 7 > 0 ? i - 7 : 0 ]; c = costs[2] + dp[ i - 30 > 0 ? i - 30 : 0 ]; dp[i] = min( min(a, b), c ); j++; } else dp[i] = dp[i - 1]; } return dp[days[days.size() - 1]]; }"},{"title":"最大正方形_统计全为1的正方形子矩阵","date":"2020-02-11T07:48:00.000Z","updated":"2020-05-08T13:43:31.903Z","comments":true,"path":"questions/leetcode/最大正方形_统计全为1的正方形子矩阵.html","permalink":"https://abc.hey-world.xyz/questions/leetcode/最大正方形_统计全为1的正方形子矩阵.html","excerpt":"","text":"题目 221 最大正方形 题目 1277 统计全为1的正方形子矩阵 题解tips： 注意matrix的类型是int还是char。 定义了动态数组，记得delete。 暴力法时间复杂度$O(mnmin(m,n)^2)$ 动态规划时间复杂度$O(mn)$ $dp(i,j)$表示以$(i,j)$为右下角，只包含1的正方形的最大边长值。 该位置为0，$dp(i,j)=0$，该位置不可能位于1的正方形中，连续性中断，重新寻找正方形。 该位置为1，$dp(i,j)$由上方、左下方、右上方三个位置的$dp$决定，状态转移方程： $$dp(i,j) = min(dp(i-1,j-1),dp(i-1,j),dp(i,j-1)) +1$$ 注意边界条件$i=0$或$j=0$，$dp(i,j)=1$。 为什么是这样的状态转移方程咧？ 图解：（来自221题解区） 代码221 int maximalSquare(vector& matrix) { if (matrix.size() == 0 || matrix[0].size() == 0) return 0; int row = matrix.size(); int col = matrix[0].size(); int **dp = new int*[row]; for (int i = 0; i < row; i++) dp[i] = new int[col]; int ansMax = 0; for (int i = 0; i < row; i++){ for (int j = 0; j < col; j++){ if (matrix[i][j] == '1') { if (i == 0 || j == 0) dp[i][j] = 1; else dp[i][j] = min( min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] ) + 1; ansMax = max(dp[i][j], ansMax); } if (matrix[i][j] == '0') dp[i][j] = 0; } } for (int i = 0; i < row; i++) delete [] dp[i]; delete [] dp; return ansMax * ansMax; } 1277 int countSquares(vector& matrix) { if (matrix.size() == 0 || matrix[0].size() == 0) return 0; int row = matrix.size(); int col = matrix[0].size(); int **dp = new int*[row]; for (int i = 0; i < row; i++) dp[i] = new int[col]; int sum = 0; for (int i = 0; i < row; i++){ for (int j = 0; j < col; j++){ if (matrix[i][j] == 1) { if (i == 0 || j == 0) dp[i][j] = 1; else dp[i][j] = min( min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] ) + 1; sum += dp[i][j]; } if (matrix[i][j] == 0) dp[i][j] = 0; } } for (int i = 0; i < row; i++) delete [] dp[i]; delete [] dp; return sum; }"},{"title":"相交链表","date":"2020-05-02T07:48:00.000Z","updated":"2020-05-02T10:23:03.613Z","comments":true,"path":"questions/leetcode/相交链表.html","permalink":"https://abc.hey-world.xyz/questions/leetcode/相交链表.html","excerpt":"","text":"题目 160 题解暴力法哈希表双指针$$a+intersection+b = b+intersection+a​$$ 当 pA 到达链表的尾部时，将它重定位到链表 B 的头结点 (你没看错，就是链表 B); 类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点。 若在某一时刻 pA 和 pB 相遇，则 pA/pB 为相交结点。 如果两个链表存在相交，它们末尾的结点必然相同。因此当 pA/pB到达链表结尾时，记录下链表 A/B 对应的元素。若最后元素不相同，则两个链表不相交。 时间复杂度 $O(m+n)$ 空间复杂度 $O(1)$ 巧妙地把指针重定向，形成了类似环形链表（没有改变输入链表）。双指针速度一致，必同时走完全程，即找到相交点。 代码双指针 ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { if (headA == nullptr || headB == nullptr) return nullptr; ListNode *pa, *pb; pa = headA; pb = headB; while (pa != pb){ pa = (pa == nullptr ? headB : pa->next); pb = (pb == nullptr ? headA : pb->next); } return pa; }"},{"title":"环形链表","date":"2020-05-02T07:48:00.000Z","updated":"2020-05-02T10:31:59.569Z","comments":true,"path":"questions/leetcode/环形链表.html","permalink":"https://abc.hey-world.xyz/questions/leetcode/环形链表.html","excerpt":"","text":"题目 141 是否有环 题解哈希表双指针快慢指针同时出发，快指针走2步，慢指针走1步，指针相遇则有环，否则无环。 代码双指针 bool hasCycle(ListNode *head) { if (head == nullptr) return false; ListNode *p, *pp; p = pp = head; while (p != nullptr && pp !=nullptr && p->next != nullptr && pp->next != nullptr){ //注意判断一下pp->next p = p->next; pp = pp->next->next; if (p == pp) return true; } return false; } 题目 142 环的入口 题解哈希表双指针（Floyd 算法）快慢指针相遇后，其一从起点出发，另一从相遇点出发，步速都为1，相遇则为环的入口点。 代码 ListNode *detectCycle(ListNode *head) { if (head == nullptr || head->next == nullptr) return nullptr; //判断一下head->next，只有一个数的单链表会影响后续判断 ListNode *p, *pp; p = pp = head; while (p != nullptr && pp !=nullptr && pp->next != nullptr){ p = p->next; pp = pp->next->next; if (p == pp) break; } if(p == pp) p = head; else return nullptr; //无环 while (p != pp){ p = p->next; pp = pp->next; } return p; } 分析假设现状是： $slow$到达环的入口处，距离起点$L_0$。 $fast$已经进入环，可能已经在环中走了$n’$圈，环长$C$，此时距离​$slow$为​$L_1$。 未来经过时间$t​$，$fast​$比$slow​$多走$n​$圈，$fast​$追上$slow​$，两指针相遇。 （1）有无环未来相遇时，从$slow$到达入口点处开始计算，$fast$比$slow$多走$n$圈： $$(L_1+2t)-t=nC$$ $$L_1+t=nC$$ 因为$L_1&lt;C$，存在$t$使得上述等式成立，$fast$多走一圈即可追上$slow$，即$n=1​$。 $n=0$表示链表是一个完整的环，头结点就是环的入口。 （2）环的入口两指针从起点到相遇点的全部路程为： $slow​$: $L_0+t​$ $fast​$: $L_0+(L_1+n’C)+2t​$ ​ 即$L_0 + t + nC+n’C​$ 注：在$slow$到达入口点这一时刻，$L_1+n’C$表示$fast$已经走过入口点的距离，$2t$表示$fast$还要再走$t$时间才能与$slow$相遇。 到相遇时，$fast​$走过的路程是$slow​$的2倍： $$2(L_0+t) = L_0 + t + nC+n’C​$$ $$L_0 = nC+n’C-t$$ 由（1）分析知，$fast$多走一圈即可追上$slow$，即$n=1​$。 $$L_0=(C-t)+n’C$$ $(C-t)​$就是从相遇点继续向前，走到环的入口点的距离。 所以， $$distance_{head_to_entrance} = distance_{cross_to_entrance}​$$"},{"title":"验证二叉搜索树","date":"2020-05-04T16:00:00.000Z","updated":"2020-05-08T11:00:26.715Z","comments":true,"path":"questions/leetcode/验证二叉搜索树.html","permalink":"https://abc.hey-world.xyz/questions/leetcode/验证二叉搜索树.html","excerpt":"","text":"题目 98 #题解 递归注意：二叉搜索树是左子树小于当前节点，与左节点小于当前节点不同。 每一个节点都把区间$(min, max)$分割成$(min, val)$和$(val, max)$两部分，成为递归条件（注意是开区间）。 这里有一个坑，$min$和$max$需要一个初始值，int和long类型的范围为$[-2147483648, 2147483647]$。测试条件含有边界值的测试样例，本应为true，由于val = -2147483648或val = 2147483647导致在下面语句中错误输出为false。 if (root-&gt;val &lt;= min || root-&gt;val &gt;= max) return false; 我的写法中偷懒将int改成long long。 较好的方法是使用递归的中序遍历，见解法二。 中序遍历中序遍历（左中右）得到的序列是升序的，可以此做判断，可用Stack实现，可递归实现。 代码递归解法一：使用long long避开边界值 bool isValidBST(TreeNode* root) { return BSTWithMaxMin(root, LONG_MIN, LONG_MAX); } bool BSTWithMaxMin (TreeNode* root, long long min, long long max) { if (!root) return true; if (root->val val >= max) return false; return BSTWithMaxMin(root->left, min, root->val) && BSTWithMaxMin(root->right, root->val, max); } 解法二：中序遍历使用节点指针prev记录前一个节点，二叉搜索树中总是prev-&gt;va &lt; node-&gt;val。 bool isValidBST(TreeNode* root) { TreeNode* prev = NULL; return validate(root, prev); } bool validate(TreeNode* node, TreeNode* &prev) { if (node == NULL) return true; if (!validate(node->left, prev)) return false; if (prev != NULL && prev->val >= node->val) return false; prev = node; return validate(node->right, prev); }"},{"title":"移除链表元素","date":"2020-05-03T03:17:00.000Z","updated":"2020-05-03T03:17:54.206Z","comments":true,"path":"questions/leetcode/移除链表元素.html","permalink":"https://abc.hey-world.xyz/questions/leetcode/移除链表元素.html","excerpt":"","text":"题目 203 #题解 tips: 删除节点时，注意防止内存泄露。 迭代初想很简单： 选择要删除节点的前一个结点 prev。 将 prev 的 next 设置为要删除结点的 next 但当要删除的节点位于头结点时，情况会变复杂。因为我们使用头结点指示后面的节点是否需要删除，没有考虑头结点需要删除的情况。可以有以下两种方式： 哨兵节点 循环判断第一个节点是否要删除 可以通过哨兵节点去解决它，哨兵节点广泛应用于树和链表中，如伪头、伪尾、标记等，它们是纯功能的，通常不保存任何数据，其主要目的是使链表标准化，如使链表永不为空、永不无头、简化插入和删除。 ListNode* sentinel = new ListNode(0); sentinel->next = head; 最后返回sentinel-&gt;next即可。 递归简洁有力的实现方式！！ 代码迭代 ListNode* removeElements(ListNode* head, int val) { if (head == nullptr) return nullptr; ListNode* p = head; while (p != nullptr && p->next != nullptr) { //头结点需删去的情况 if(p == head && p->val==val){ ListNode* tmp = head; p = head = head->next; delete tmp; continue; } (p->next->val == val)? p->next = p->next->next : p = p->next; } //只有一个结点时，不进入while循环，故需再判断一次 if (head->val == val) return nullptr; else return head; } 递归 ListNode* removeElements(ListNode* head, int val) { //结束标志 if (!head) return head; //自上而下 head->next = removeElements(head->next, val); //关系，注意防止内存泄露 if (head->val == val){ ListNode* tmp = head; head = head->next; delete tmp; } return head; }"},{"title":"实现Singleton模式","date":"2020-10-09T04:17:00.000Z","updated":"2020-02-11T03:59:35.920Z","comments":true,"path":"questions/offer/002_实现Singleton模式.html","permalink":"https://abc.hey-world.xyz/questions/offer/002_实现Singleton模式.html","excerpt":"c#实现单例模式。","text":"c#实现单例模式。 题目 002设计一个类，只能生成该类的一个实例。 分析要求只能生成一个实例，构造函数设为私有，其他类不能直接调用该类生成新的对象。“只能生成一个”，想到static的特性。 几种解法 方法一：判断静态成员变量是否为空，只适用于单线程。 方法二：在方法一的基础上，加同步锁再判断，可用于多线程。 方法三：修改方法二，加同步锁前后两次判断，减少加锁操作，提高效率。 方法四：静态构造函数，可能会过早地创建实例。 创建第一个类实例或任何静态成员被引用时，.NET将自动调用静态构造函数来初始化类。 public sealed class Singleton4 { private Singleton4(){} private static Singleton4 instance = new Singleton4(); public static Singleton4 Instance { get { return instance; } } } 方法五：按需创建，嵌套类+静态函数。 父类的方法用static修饰，是为了绕过类的实例化来调用函数。【必须】 子类的方法和变量用static修饰，是因为静态方法不能直接调用非静态成员。 public sealed class Singleton5 { Singleton5(){} public static Singleton5 Instance { get { return Nested.instance; } } class Nested { static Nested(){} internal static readonly Singleton5 instance = new Singleton5(); } } 对方法五做如下修改，使得在Nested类中，不使用静态函数和变量（即方法五中子类不适用static），可达到相同效果： public sealed class Singleton5 { Singleton5(){} public static Singleton5 Instance { get { Nested n = new Nested(); //modified return n.instance; //modified } } public class Nested { internal Nested(){} //modified internal readonly Singleton5 instance = new Singleton5(); //modified } } 扩展什么时候可以不用实例化对象就可以调用类中成员函数？ 类的静态成员函数。 非静态成员函数没有使用类的非静态数据成员，调用的其他非静态成员函数也不能使用类的非静态数据成员。 非静态成员函数调用类的静态数据成员。 （后面两种可以概括为【non-static的东西没有调用non-static的东西】） 来源：https://blog.csdn.net/dwb1015/article/details/32933349"},{"title":"数组中的重复数字","date":"2020-02-11T04:13:00.000Z","updated":"2020-02-11T07:15:50.063Z","comments":true,"path":"questions/offer/003_数组中的重复数字.html","permalink":"https://abc.hey-world.xyz/questions/offer/003_数组中的重复数字.html","excerpt":"","text":"题目 003在一个长度为n的数组里的所有数字都在$0$到$n-1$的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组${2,3,1,0,2,5,3}$，那么对应的输出是第一个重复的数字$2$。 题目一：可修改输入数组 题目二：不可修改输入数组 几种解法 序号 方法 时间复杂度 空间复杂度 备注 题目一_方法1 排序 $O(n\\text{log}n)$ $O(1)$ 题目一_方法2 哈希 $O(n)$ $O(n)$ 题目一_方法3 按下标重排数组 $O(n)$ $O(1)$ 每个数字最多交换2次 题目二_方法1 二分+区间计数 $O(n\\text{log}n)$ $O(1)$ 不能找出所有重复 我的解法与方法二类似，布尔类型的哈希表。"},{"title":"替换空格","date":"2020-02-11T07:52:00.000Z","updated":"2020-02-11T10:27:34.428Z","comments":true,"path":"questions/offer/005_替换空格.html","permalink":"https://abc.hey-world.xyz/questions/offer/005_替换空格.html","excerpt":"替换字符串中的每个空格。","text":"替换字符串中的每个空格。 题目 005请实现一个函数，将一个字符串中的每个空格替换成%20。例如，当字符串为​We Are Happy.则经过替换之后的字符串为We%20Are%20Happy.。 推荐解法遍历数组获取长度，可计算新数组长度，从后向前复制替换，注意结尾的’\\0’。 https://github.com/zhedahht/CodingInterviewChinese2/blob/master/05_ReplaceSpaces/ReplaceSpaces.cpp 我的解法笨蛋解法，由于空格替换成%20会改变数组长度，借用另一个vector做转换。时间$O(n)$，空间$O(n)$。 void replaceSpace(char *str,int length) { //length为字符数组的有效长度 vector res; int count = 0; int len = 0; //len记录字符数组的实际长度 while(str[len] != '\\0'){ if (str[len] == ' '){ res.push_back('%'); res.push_back('2'); res.push_back('0'); count++; } else res.push_back(str[len]); len++; } if (len + count * 2 > length) return; for (int i = 0; i < len + count * 2; i++) str[i] = res[i]; str[len + count * 2] = '\\0'; \\\\字符数组结尾 } 总结合并两个数组，涉及重复移动元素，可以考虑从后往前。 字符串与字符数组的长度 字符数组的有效长度$\\neq$实际长度 数组形参char*等价于char []等价于char[100]， 编译器会忽略任何为数组形参指定的长度 。64位时，sizeof(形参) = 8；32位时，sizeof(形参) = 4。 strlen函数计算到’\\0’停止；sizeof计算包含’\\0’。 字符数组与字符串的区别：字符数组是一个数组，每个元素的值都可以改变。而字符串指针指向的是一个常量字符串，它被存放在程序的静态数据区，一旦定义就不能改变。 #include //strlen()头文件 char str1[] = \"hello world\"; strlen(str1); //11 sizeof(str1)/sizeof(char); //12 char* str2 = \"hello world\"; strlen(str2); //11 sizeof(str2)/sizeof(char); //8 char str3[100] = \"hello world\"; strlen(str3); //11 sizeof(str3)/sizeof(char); //100 //等同于char str4[5] char str4[] = {'h','e','l','l','o'}; //字符数组不要求最后一个字符为'\\0' strlen(str4); //5 sizeof(str3)/sizeof(char); //8 char str5[6] = {'h','e','l','l','o'}; //其余元素自动复制为空字符'\\0' strlen(str3); //5 sizeof(str3)/sizeof(char); //6 参考： https://www.jianshu.com/p/513d817e87e9``` ```"},{"title":"二维数组中的查找","date":"2020-02-11T07:48:00.000Z","updated":"2020-02-11T07:56:56.612Z","comments":true,"path":"questions/offer/004_二维数组中的查找.html","permalink":"https://abc.hey-world.xyz/questions/offer/004_二维数组中的查找.html","excerpt":"有序二维数组中查找一个数字。","text":"有序二维数组中查找一个数字。 题目 004在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。$$\\begin{matrix}1&amp;2&amp;8&amp;9\\2&amp;4&amp;9&amp;12\\4&amp;7&amp;10&amp;13\\6&amp;8&amp;11&amp;15\\end{matrix}$$ 分析矩阵有序，从数组中选取一个数字时，有三种情况： $num{select}=num{target}$，返回。 $num{select}&lt;num{target}$，查找数字的右边或下面。 $num{select}&gt;num{target}$，查找数字的左边或上面。 推荐解法情况2和3存在重叠区域，从右上或左下的角点开始查找，可以将情况2和3简化成各一个查找区域。 bool Find(int* matrix, int rows, int columns, int number) { bool found = false; if(matrix != nullptr && rows > 0 && columns > 0) { int row = 0; int column = columns - 1; while(row < rows && column >=0) { if(matrix[row * columns + column] == number) { found = true; break; } else if(matrix[row * columns + column] > number) -- column; else ++ row; } } return found; } 我的解法对每一行二分查找。（没有充分利用行间的有序性） bool Find(int target, vector array) { if (array.size() == 0 || array[0].size() == 0) return false; for (unsigned int i = 0; i < array.size(); i++) { bool sign = FindMid(target, array, i, 0, array[0].size() - 1); if (sign == true) return true; } return false; } bool FindMid(const int target, vector array, const unsigned int row, unsigned int begin, unsigned int end) { unsigned int mid = (begin + end) / 2; if (array[row][mid] == target) return true; if (end - begin == 1) { if (array[row][end] == target) return true; else return false; } if (array[row][mid] < target) return FindMid(target, array, row, mid, end); else return FindMid(target, array, row, begin, mid); } 记录一开始在想这个问题的时候，从二维数组的中间选取一个数字进行比较，只考虑了右下和左上，漏掉了很多区域，没有想清楚。"},{"title":"从尾到头打印链表","date":"2020-02-11T14:28:00.000Z","updated":"2020-02-11T15:02:49.824Z","comments":true,"path":"questions/offer/006_从尾到头打印链表.html","permalink":"https://abc.hey-world.xyz/questions/offer/006_从尾到头打印链表.html","excerpt":"","text":"题目 006输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 推荐解法打印通常是一个只读操作，不希望改变链表，先遍历链表。 解法一 【栈】后进先出void PrintListReversingly_Iteratively(ListNode* pHead) { std::stack nodes; ListNode* pNode = pHead; while(pNode != nullptr) { nodes.push(pNode); pNode = pNode->m_pNext; } while(!nodes.empty()) { pNode = nodes.top(); nodes.pop(); } } 解法二：【递归】本质上是一个栈结构链表很长时，调用层级深，可能导致调用栈溢出，鲁棒性较解法一稍差。 void PrintListReversingly_Recursively(ListNode* pHead) { if(pHead != nullptr) { if (pHead->m_pNext != nullptr) { PrintListReversingly_Recursively(pHead->m_pNext); } } } 我的解法 分别用步长为1、2的指针遍历，当步长为2的指针完成遍历，步长为1的指针走到中间。 交换对称位置的节点数值。 时间复杂度$O(n)$，空间复杂度$O(n)$。 vector reversePrint(ListNode* head) { vector res; if (head == NULL) return res; ListNode* p = head; ListNode* pp = head; int index = 0; while (pp != NULL && pp->next != NULL) { //分别用步长为1、2的指针找到中间指针 res.push_back(p->val); p = p->next; pp = pp->next->next; index++; } int count = 1; //用于交换数字时，index往两侧移动 if (pp != NULL && pp->next == NULL) { //数目为奇数，中间数不用交换，多走一步 res.push_back(p->val); p = p->next; } while (p != NULL) { //交换两侧数字 res.push_back(res[index - count]); res[index - count] = p->val; p = p->next; count++; } return res; }"},{"title":"","date":"2020-02-11T07:48:00.000Z","updated":"2020-02-11T07:51:47.686Z","comments":true,"path":"questions/offer/模板.html","permalink":"https://abc.hey-world.xyz/questions/offer/模板.html","excerpt":"","text":"题目 0"}],"posts":[{"title":"frp内网渗透实现流畅远程办公","slug":"frp内网渗透实现流畅远程办公","date":"2020-04-30T08:33:34.000Z","updated":"2020-04-30T09:31:55.549Z","comments":true,"path":"2020/04/30/frp内网渗透实现流畅远程办公/","link":"","permalink":"https://abc.hey-world.xyz/2020/04/30/frp内网渗透实现流畅远程办公/","excerpt":"疫情在家，需要远程连接机器，奈何家里网速不快，在笔记本上使用向日葵和teamviewer延迟严重，于是尝试了Windows自带的远程桌面（Microsoft Remote Desktop），配置较麻烦，但使用流畅。","text":"疫情在家，需要远程连接机器，奈何家里网速不快，在笔记本上使用向日葵和teamviewer延迟严重，于是尝试了Windows自带的远程桌面（Microsoft Remote Desktop），配置较麻烦，但使用流畅。 Windows远程桌面依靠分发指令，Teamviewer依靠图像传输。Windows桌面通过RDP协议进行远程控制，不需要额外安装。RDP（Remote Desktop Protocol）是微软开发的基于连接远程计算机的协议。局域网内远程桌面较简单，见参考[1][2]。外网远程桌面需要借助一个公网IP使用frp进行内网渗透。 frpfrp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp 协议，为 http 和 https 应用协议提供了额外的能力，且尝试性支持了点对点穿透。 部署架构可以看出，我们需要在具有公网IP的机器上部署frps，在位于内网环境的被操控机器上部署frpc。 个人部署环境 具有公网IP的机器：一台阿里云学生机 Ubuntu 位于内网的物理机：一台或多台被远程操控的机器 Win10 用户机：一台笔记本 Win10 步骤在公网机器上 安装wget apt-get install -y wget 下载frp，解压并重命名 wget https://github.com/fatedier/frp/releases/download/v0.33.0/frp_0.33.0_linux_amd64.tar.gz tar -zxvf frp_0.33.0_linux_amd64.tar.gz mv frp_0.33.0_linux_amd64 frp 进入frp，修改配置frps.ini cd frp vim frps.ini frps.ini文件如下配置： [common] # 要绑定的端口 bind_port = 7000 # 安全授权 token，防止端口被扫描到后可以被任意客户端连接，可自己设置 token = 12345678 # 控制台的用户名 dashboard_user = user # 控制台的密码 dashboard_pwd = password # 控制台的端口 dashboard_port = 7500 配置防火墙端口（阿里云ECS安全组规则）【注意】！！ 配置公网机器与被远程机器通信的bind_port端口 配置公网机器与用户客户端机器通信的remote_port端口 给frp提权，运行frp sudo chmod -R 777 ~/frp ./frps -c ./frps.ini 运行成功会显示Start frps success，不要结束命令。如需进行其他操作，可使用screen命令创建多个会话。 在物理机上 下载win10对应版本frp并解压 https://github.com/fatedier/frp/releases/download/v0.33.0/frp_0.33.0_windows_amd64.zip 修改frpc.ini [common] # 公网IP server_addr = xxx.xxx.xxx.xxx # 服务器上设置的服务绑定端口(frps.ini 中的 bind_port) server_port = 7000 # 安全授权 token，需与服务端设置一致（可自定义，可删去） token = 12345678 [RDP] # 反向代理名称，可以随意设置，若设置多台物理机，此处需区别命名 type = tcp local_ip = 127.0.0.1 local_port = 3389 # 外网访问的端口 remote_port = 6000 若设置多台机器，第二台机器可把[RDP]改为[RDP1]，把外网访问端口由6000改为6001。 开启远程桌面：“控制面板”——“系统”——“远程设置”——“允许远程连接至此电脑”。 cmd命令进入frp文件夹，运行如下命令： frpc.exe -c frpc.ini 运行成功会显示start proxy success，不要结束cmd命令窗口。 在用户机上 设置打开远程桌面：“设置”——“远程桌面”——“开“ 连接远程桌面 输入公网IP:外网访问的端口，输入被远程控制机器的系统用户名和密码。若远程操作多台机器，登录时需改变端口和用户名密码。 ​ 使用感受 日常操作速度：Windows远程桌面&gt;TeamViewer 传文件使用Teamviewer的file transfer更方便 Windows远程桌面打开Matlab报错：MATLAB cannot be started through terminal services，可修改license，见[6]。 对于CloudCompare软件，Windows远程桌面无法打开，可用teamviewer。 Reference[1] WIN10远程控制（局域网） [2] 怎样远程控制局域网的另一台电脑（远程桌面）windows10 [3] 使用 FRP 实现在家远程桌面到公司内网进行远程办公 [4] windows下基于frp的内网穿透部署 [5] FRP内网穿透转发Windows远程桌面端口 详细教程 [6] 如何远程登录Windows服务器或者主机，并使用主机上的Matlab？","categories":[{"name":"工具","slug":"工具","permalink":"https://abc.hey-world.xyz/categories/工具/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"https://abc.hey-world.xyz/tags/搜索/"}]},{"title":"解决xftp5：要继续使用此程序，您必须应用最新的更新或使用新版本","slug":"不升级解决xftp5：要继续使用此程序，您必须应用最新的更新或使用新版本","date":"2019-04-24T13:19:08.000Z","updated":"2020-04-30T09:30:22.691Z","comments":true,"path":"2019/04/24/不升级解决xftp5：要继续使用此程序，您必须应用最新的更新或使用新版本/","link":"","permalink":"https://abc.hey-world.xyz/2019/04/24/不升级解决xftp5：要继续使用此程序，您必须应用最新的更新或使用新版本/","excerpt":"","text":"不升级，解决xftp5：要继续使用此程序，您必须应用最新的更新或使用新版本。 文本方式打开nslicense.dll 搜索16进制 7F0C81F98033E1010F8680修改为 7F0C81F98033E101E98100 或 7F0C81F98033E1010F8380 参考：Xshell无法启动：要继续使用此程序，您必须应用最新的更新或使用新版本","categories":[{"name":"warning&error","slug":"warning-error","permalink":"https://abc.hey-world.xyz/categories/warning-error/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"https://abc.hey-world.xyz/tags/搜索/"}]},{"title":"Windows下通过sublime text批量替换多个文件","slug":"Windows下通过sublime-text批量替换多个文件","date":"2019-04-24T12:28:54.000Z","updated":"2020-04-30T09:31:07.456Z","comments":true,"path":"2019/04/24/Windows下通过sublime-text批量替换多个文件/","link":"","permalink":"https://abc.hey-world.xyz/2019/04/24/Windows下通过sublime-text批量替换多个文件/","excerpt":"","text":"Linux系统下可以用sed命令一键替换，Windows下的懒人模式，发现sublime text的新用途。 sublime text选择“文件”-“打开文件夹” 把含有要替换文本的文件放在一个文件夹内（可以包含多层级多个子文件夹），选择该文件夹。 在文件夹处右键“在文件夹中查找”，即可在多个文件中查找或替换文本。 左下角表示支持正则、大小写、全词匹配","categories":[{"name":"工具","slug":"工具","permalink":"https://abc.hey-world.xyz/categories/工具/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"https://abc.hey-world.xyz/tags/搜索/"}]},{"title":"用python为png图片加上背景色","slug":"用python为png图片加上背景色","date":"2018-07-28T08:43:19.000Z","updated":"2018-07-28T08:48:04.181Z","comments":true,"path":"2018/07/28/用python为png图片加上背景色/","link":"","permalink":"https://abc.hey-world.xyz/2018/07/28/用python为png图片加上背景色/","excerpt":"","text":"安装Pillow库ImportError: No module named PIL 错误 的解决方法： pip install Pillow 代码from PIL import Image as Image im = Image.open('cropped-1920-1080-744835.png') x,y = im.size try: p = Image.new('RGB', im.size, (178, 235, 242)) #创建背景色图像 p.paste(im, (0, 0, x, y), im) #将原图粘贴到背景图像上 p.save('out-cropped-1920-1080-744835.png') except: pass PIL.Image.new(mode, size, color=0)Creates a new image with the given mode and size. mode 1 (1-bit pixels, black and white, stored with one pixel per byte) L (8-bit pixels, black and white) P (8-bit pixels, mapped to any other mode using a color palette) RGB (3x8-bit pixels, true color) RGBA (4x8-bit pixels, true color with transparency mask) CMYK (4x8-bit pixels, color separation) YCbCr (3x8-bit pixels, color video format) Note that this refers to the JPEG, and not the ITU-R BT.2020, standard LAB (3x8-bit pixels, the Lab color space) HSV (3x8-bit pixels, Hue, Saturation, Value color space) I (32-bit signed integer pixels) F (32-bit floating point pixels) Image.paste(im, box=None, mask=None)**Parameters: im – Source image or pixel value (integer or tuple). box – An optional 4-tuple giving the region to paste into. If a 2-tuple is used instead, it’s treated as the upper left corner. If omitted or None, the source is pasted into the upper left corner. If an image is given as the second argument and there is no third, the box defaults to (0, 0), and the second argument is interpreted as a mask image. 四元组：左上右下 mask – An optional mask image. 引用python通过pil为png图片填充上背景颜色 Image Module | Pillow","categories":[{"name":"工具","slug":"工具","permalink":"https://abc.hey-world.xyz/categories/工具/"}],"tags":[{"name":"python","slug":"python","permalink":"https://abc.hey-world.xyz/tags/python/"},{"name":"png","slug":"png","permalink":"https://abc.hey-world.xyz/tags/png/"}]},{"title":"C++如何判断整型运算溢出","slug":"C-如何判断整型运算溢出","date":"2017-08-04T08:27:08.000Z","updated":"2018-07-27T11:41:55.177Z","comments":true,"path":"2017/08/04/C-如何判断整型运算溢出/","link":"","permalink":"https://abc.hey-world.xyz/2017/08/04/C-如何判断整型运算溢出/","excerpt":"","text":"整数在计算机中主要由补码表示，分为无符号整数和有符号整数。若用i位表示整数，无符号整数的范围 $[0 , 2^i - 1]$ ，有符号整数的范围 $ [- 2 ^ {i-1} , 2^{i-1} - 1 ]$ 阅读：整数在计算机中的表示 针对32位整型讨论 加法无符号整型溢出舍去一位，相当于$ a+b - 2^i$ ，有 a+b &lt; a 或者 a+b &lt; b 。 更长的临时变量保存 int is_overflow_add_for_unsigned_int( unsigned int a, unsigned int b ) { long sum = a + b; return a + b &lt; a || a + b &lt; b; } 另一种 int is_overflow_add_for_unsigned_int( unsigned int a, unsigned int b ) { return UINT_MAX - a &lt; b; } 有符号整型只有正溢出、负溢出两种情况。 int is_overflow_add_for_signed_int( int a, int b ) { int sum = a + b; if (a > 0 &amp;&amp; b > 0 &amp;&amp; sum &lt; 0) return 1; if (a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; sum > 0) return 1; return 0; } int is_overflow_add_for_signed_int( int a, int b ) { return a >= 0 ? INT_MAX - a &lt; b : INT_MIN - a > b; } 乘法int is_overflow_multiply_for_signed_int(int a,int b){ int mul=a*b; return !a||mul/a==b; } int is_overflow_multiply_for_unsigned_int( unsigned int a, unsigned int b ) { return a == 0 ? 0 : UINT_MAX / a &lt; b; } int is_overflow_multiply_for_signed_int( int a, int b ) { return a == 0 ? 0 : a > 0 &amp;&amp; b > 0 || a &lt; 0 &amp;&amp; b &lt; 0 ? INT_MAX / a &lt; b : INT_MIN / a > b; } 赋值判断溢出先用大一倍位长的临时变量保存，然后再看看截断后跟原值是不是一样。 long y = x * 10 + x % 10; int res = y; if(res == y) return 0; else return 1; 参考 如何判断整型算术运算是否溢出 两个int变量相乘如何判断溢出？","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://abc.hey-world.xyz/tags/C/"},{"name":"溢出","slug":"溢出","permalink":"https://abc.hey-world.xyz/tags/溢出/"}]},{"title":"博客常用","slug":"hexo博客中编辑LaTex公式","date":"2017-06-30T16:31:28.000Z","updated":"2018-07-27T11:41:55.178Z","comments":true,"path":"2017/07/01/hexo博客中编辑LaTex公式/","link":"","permalink":"https://abc.hey-world.xyz/2017/07/01/hexo博客中编辑LaTex公式/","excerpt":"集合多文，方便查看","text":"集合多文，方便查看 hexo命令s 启动服务器hexo g 生成静态文件hexo d 部署hexo new &quot;文章名&quot; 新建文章hexo clean 清除缓存文件和生成的静态文件markdown语法markdown语法编辑 粗体 斜体 删除 分割线 标题 # 一级标题## 二级标题……###### 六级标题 列表、表格 无序 列表 有序 列表 Tables （靠左） Are （居中） Cool （靠右） col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 引用、代码 引用 行内标记 多行代码 图片、链接 text LaTex 数学公式脚本&lt;script type=\"text/javascript\" src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default\">&lt;/script> 公式 行内公式 $y=x$ 整行公式 $$y=x$$ 语法 上标 x^2 x^{31} （注：{}用于分组） 下标 x_2 markdown与hexo自带的marked产生的语法冲突手动加转义符\\ 符号 markdown hexo-render-marked _ 两个\\_之间，表示强调 下标 * 两个\\*之间，表示斜体 乘号 其他与 sublime text 插件 Markdown Preview配合使用自动间隔刷新，文章中插入如下： &lt;meta http-equiv=&quot;refresh&quot; content=&quot;0.1&quot;&gt; 参考hexo指令Markdown——入门指南Markdown进阶语法整理Hexo下mathjax的转义问题","categories":[{"name":"博客","slug":"博客","permalink":"https://abc.hey-world.xyz/categories/博客/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://abc.hey-world.xyz/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://abc.hey-world.xyz/tags/博客/"}]},{"title":"决策树之ID3","slug":"决策树之ID3","date":"2017-06-08T08:28:27.000Z","updated":"2018-07-27T11:41:55.181Z","comments":true,"path":"2017/06/08/决策树之ID3/","link":"","permalink":"https://abc.hey-world.xyz/2017/06/08/决策树之ID3/","excerpt":"","text":"概念决策树是一棵多叉树，每个非叶子节点用一个输入特征标记，每个分支用该特征的一个可能值标记，每个叶节点用类别的一个元素标记。 决策树算法，在训练阶段，用样本数据构造一棵决策树，作为分类器。学习的结果是一个决策树。 两个问题什么样的特征分类能力最好？采用熵，作为系统无序化程度的度量。信息熵：信源不确定度。$ H \\left (U \\right) = E \\left [ - \\log p_{i} \\right ] = - \\sum_{i=1}^{n} p_{i} \\log p_{i} $值得注意的是，信息集合的体量越大，熵也越大。所以用集合中样本数量的占比来为集合加权，引入信息增益。 信息增益：特征给系统带来的信息量。熵减 = 信息增$ IG \\left ( S , T \\right) = E \\left( S \\right ) - \\sum_{i=0}^{N} \\frac{D_{i}}{D_{S}} E \\left( S_{i} \\right) $ 延伸 互信息 ：变量间相互依赖性的量度知道其中一个变量提供的另一个的信息量（即不确定度的减少量）知道 X 后 Y 的不确定度的量的减少程度 = Y的不确定度 - 在 X 已知之后 Y 的剩余不确定度的量 怎样的结点是叶子结点？ 情况 判断条件 纯结点 $ \\max IG = 0 $ 非纯结点，而且当前所有的特征都测试完 $ \\max IG = 0 $ 空结点 样本数 = 0 对于纯叶子结点，若再用任意特征划分：对于纯结点集合S，有两种情况，一是样本全属于某类别$ p_{i} = 1 $，则$ \\log_{2} p_{i} = 0 $；一是$ p_{i} = 0 $。此时再用任一特征把S划分为k个子集合$ S_{1},S_{2},…,S_{k} $，全是纯结点，信息熵为零，故$ IG \\left ( S , T \\right) = E \\left( S \\right ) - \\sum_{i=0}^{k} \\frac{D_{i}}{D_{S}} E \\left( S_{i} \\right) = 0 $ 对于非纯叶结点，所有特征测试完，再选任一特征进行划分：相当于重复测试特征，得到的子集合 = 父集合。","categories":[{"name":"模式识别","slug":"模式识别","permalink":"https://abc.hey-world.xyz/categories/模式识别/"}],"tags":[{"name":"有监督学习","slug":"有监督学习","permalink":"https://abc.hey-world.xyz/tags/有监督学习/"}]},{"title":"人工神经网络之BP算法","slug":"人工神经网络之BP算法","date":"2017-06-06T14:23:21.000Z","updated":"2018-07-27T11:41:55.179Z","comments":true,"path":"2017/06/06/人工神经网络之BP算法/","link":"","permalink":"https://abc.hey-world.xyz/2017/06/06/人工神经网络之BP算法/","excerpt":"","text":"相关概念神经网络，是一种应用类似于大脑神经突触连接结构进行信息处理的数学模型。一个神经元包含一个细胞体、一些树突和一根很长的轴突。 如何模拟大脑神经元之间有权重的链接将信号从一个神经元传递到另一个神经元。每个神经元连接到几个输入信号，但不会产生多于一个输出信号。（输入层不算。一层中间层+输出层=两层神经网络） 人工神经网络ANN，是一个非线性有向无环图。神经元的信号强弱——分支不分流。 生物 人工 细胞体 神经元 树突 输入 轴突 输出 突触 权重 如何学习神经元通过链接相连，每个链接都有权重。学习的是权重。 发展萌芽期 MP模型 阈值加权和 $ 一个神经元 = \\sum_{i=0}^{N} 强度 * 权重 - 抑制能力 $ 第一次高潮 Perceptron 单级感知器 一层的神经网络（没有中间层，只能解决线性问题） 第二次高潮 Hopfield网络 Boltzmann机 BP算法 BP算法","categories":[{"name":"模式识别","slug":"模式识别","permalink":"https://abc.hey-world.xyz/categories/模式识别/"}],"tags":[{"name":"有监督学习","slug":"有监督学习","permalink":"https://abc.hey-world.xyz/tags/有监督学习/"}]},{"title":"这些电脑小工具","slug":"这些电脑小工具","date":"2017-03-07T09:38:38.000Z","updated":"2019-04-24T14:28:05.942Z","comments":true,"path":"2017/03/07/这些电脑小工具/","link":"","permalink":"https://abc.hey-world.xyz/2017/03/07/这些电脑小工具/","excerpt":"写于2017-03-07 2019-04-24更新 这是一篇正经的安利小文，关于电脑上的一些小工具，特别分享给二狗和二二同学~ 在电脑上各种软件或网站，总会遇到挺多的限制，这时候喜欢找些奇奇怪怪的东西，帮自己提高提高效率，而且，发现新事物的过程也是特别愉快，每次都惊叹于人民群众的劳动智慧。","text":"写于2017-03-07 2019-04-24更新 这是一篇正经的安利小文，关于电脑上的一些小工具，特别分享给二狗和二二同学~ 在电脑上各种软件或网站，总会遇到挺多的限制，这时候喜欢找些奇奇怪怪的东西，帮自己提高提高效率，而且，发现新事物的过程也是特别愉快，每次都惊叹于人民群众的劳动智慧。 原始人制作了石锤、石斧等，技能满点，想方设法合作把许多有威胁的大型动物团灭，过上喝酒吃肉的快意生活。当然，只会专注于收集工具而不用，也就是个摆设罢。 工具的来源或教程，大多来自度娘、知乎、吾爱论坛，此处不表，自行百度咯。 软件远程&amp;命令行putty连接服务器 gitteamviewer可以ipad控制电脑 Cmder好用的命令行 xftpftp 学习PDF-Viewerpdf阅读器，轻量，支持自定义快捷键添加笔记。NICE Xmind思维导图 Citavi论文管理 Visio画图 OneDrive资料同步 OneNote——笔记整理以前用印象笔记，奈何断断续续出问题，登录失败，弃之。如果电脑装了Office，已经顺带装好了OneNote桌面版。 按Tab键自动生成表格 可自定义标记+配合快捷键 自由移动一大块 绘图功能，配合可触屏的笔记本更佳 可以找插件，如代码高亮 复制文字，粘贴转图片 插入文件、音频等…… 笔记本分区无限（笔记本里的笔记本里的……笔记）等等~ ##英语 Aboboo可练习英语听写、跟读。 MDict词典，可自行添加各种词典。 Anki——单词记忆工具，自制词库（不只限制于单词）。有正反卡片，填空等格式 写博客Typoramarkdown编辑器 PicGo图床工具 PotPlayer &amp; VLC——播放器支持倍速播放，看视频课加快语速 QQ影音Mp4转Mp3格式 小工具日常操作Everything查找文件，非常快。 Snipaste截图，且截图可编辑加文字等。 DeskPins窗口置顶。配合chrome插件separate window可以边看小窗看视频边干活。 Ditto复制粘贴工具，支持多次复制，选择性粘贴。 SnapTimer倒计时 Sticky NotesWin10自带便签 Rocket Dock模仿linux底部菜单 系统监控CCleaner电脑清洁 Speccy64硬件监控 视频下载 b站 ——在网址bilibili前面加i或后面加jj，可跳转 爱课程网 ——爱课程课程助手地瓜专版 网易公开课 ——网易云课堂课程下载器v2.2配合PotPlayer，棒(●’◡’●)音乐 集合下载工具 ——音乐间谍V3.4 配合网易云音乐，上传到我的音乐云盘，电脑手机同步听。 Spotify： 调教一段时间后，推荐很合口味。适合在线听歌，免费版只能随机打乱听。有安卓端。 ChromeChrome插件Momemtun——漂亮的标签页 LastPass——管理密码 Clip to OneNote——配合OneNote的剪切工具 OneTab——把暂时不用的标签页变成一个，节省内存。对于喜欢一次打开十几个标签页的我，福音！！ 一键管理所有拓展——快速禁用插件 EyeDropper——网页取色工具强迫症用ps时的福音 Violent Monkey——脚本管理 配合某脚本+迅雷破解版，用迅雷下载百度云的大文件，具体搜知乎 Diigo网页摘录 Chrome应用Gliffy Diagrams——画流程图等 Halo Word——词典，按Ctrl查词 Postman发送http请求","categories":[{"name":"随笔","slug":"随笔","permalink":"https://abc.hey-world.xyz/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://abc.hey-world.xyz/tags/随笔/"}]}]}